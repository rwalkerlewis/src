/* This file is automatically generated. DO NOT EDIT! */

#ifndef _allp2_h
#define _allp2_h


typedef struct Allpass2 *allpas2;
/* abstract data type */


allpas2 allpass2_init(int nw         /* filter order */, 
		       int nj         /* filter step */, 
		       int nx, int ny /* data size */, 
		       float **pp     /* dip [ny][nx] */);
/*< Initialize >*/


void allpass2_close(allpas2 ap);
/*< free allocated storage >*/


void allpass22_init (allpas2 ap1);
/*< Initialize linear operator >*/


void allpass21_lop (bool adj, bool add, int n1, int n2, float* xx, float* yy);
/*< PWD as linear operator >*/


void allpass21 (bool der          /* derivative flag */, 
		const allpas2 ap /* PWD object */, 
		float** xx        /* input */, 
		float** yy        /* output */);
/*< plane-wave destruction >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _allp3_h
#define _allp3_h


typedef struct Allpass *allpass;
/* abstract data type */


allpass allpass_init(int nw                 /* filter size */, 
		     int nj                 /* filter step */, 
		     int nx, int ny, int nz /* data size */, 
		     float *pp              /* dip [nz*ny*nx] */);
/*< Initialize >*/


void allpass_close(allpass ap);
/*< free allocated storage >*/


void allpass1 (bool left        /* left or right prediction */,
	       bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< in-line plane-wave destruction >*/


void allpass1t (bool left        /* left or right prediction */,
	       bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< adjoint of in-line plane-wave destruction >*/


void left1 (bool left        /* left or right prediction */,
	       bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< left part of in-line plane-wave destruction >*/


void right1 (bool left        /* left or right prediction */,
	       bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< right part of in-line plane-wave destruction >*/


void allpass2 (bool left        /* left or right prediction */,
	       bool der         /* derivative flag */, 
	       const allpass ap /* PWD object */, 
	       float* xx        /* input */, 
	       float* yy        /* output */);
/*< cross-line plane-wave destruction >*/


void allpass3_init (allpass ap, allpass aq);
/*< Initialize linear operator >*/


void allpass3_lop (bool adj, bool add, int n1, int n2, float* xx, float* yy);
/*< PWD as linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _apfilt_h
#define _apfilt_h


void apfilt_init(int nw /* filter order */);
/*< initialize >*/


void apfilt_close(void);
/*< free allocated storage >*/


void passfilter (float p  /* slope */, 
		 float* a /* output filter [n+1] */);
/*< find filter coefficients >*/


void aderfilter (float p  /* slope */, 
		 float* a /* output filter [n+1] */);
/*< find coefficients for filter derivative >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _beamform_h
#define _beamform_h


#include <rsf.h>


void beamform_init(bool gauss1    /* pseudo-gaussian */,
		   int m1, int m2 /* data dimensions */, 
		   int rect1      /* triangle radius */);
/*< initialize >*/


void beamform_set(float** p /* slope [m2][m1] */);
/*< set slopes >*/


void beamform_close(void);
/*< free allocated storage >*/


void beamform_lop(bool adj, bool add, int nc, int nd, float* c, float* d);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _callp2_h
#define _callp2_h


#include <rsf.h>


typedef struct Callpass2 *callpass2;
/* abstract data type */


callpass2 callpass2_init(int nw          /* filter size (1,2,3) */, 
			 int nj          /* filter step */, 
			 int nx , int ny /* data size */);
/*< Initialize >*/


void callpass2_close(callpass2 ap);
/*< Free allocated storage >*/


void callpass21_set (callpass2 ap, float p /* constant dip */);
/*< set dip >*/


void callpass21 (bool der           /* derivative flag */, 
		 const callpass2 ap /* PWD object */, 
		 float** xx         /* input */, 
		 float** yy         /* output */);
/*< plane-wave destruction >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _cgtest_h
#define _cgtest_h


void cgtest(int nx, int ny, float *x, 
	    const float *yy, float **fff, int niter);
/*< testing conjugate gradients with matrix multiplication >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _copyk_h
#define _copyk_h


void copyk_init(int nk1 /* number of components */,
		int n1  /* size of one component */);
/*< initialize >*/


void copyk_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _cpwd_h
#define _cpwd_h


#include <rsf.h>


typedef struct Cpwd *cpwd; /* abstract data type */


cpwd cpwd_init(int n1 /* trace length */, 
	       int nw /* filter order */);
/*< initialize >*/


void cpwd_close (cpwd w);
/*< free allocated storage >*/


float cpwd_define (bool adj    /* adjoint flag */, 
		   cpwd w       /* cpwd object */, 
		   float pp     /* slope */, 
		   float* offd /* defined off-diagonal */);
/*< fill the matrix (returns the diagonal) >*/


void cpwd_set (bool adj   /* adjoint flag */,
	       cpwd w      /* cpwd object */, 
	       float* inp /* input */, 
	       float* out /* output */, 
	       float* tmp /* temporary storage */);
/*< matrix multiplication >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _dijkstra_h
#define _dijkstra_h


#include <rsf.h>


void dijkstra_init(int m1, int m2, 
		   float **udcost  /* up-down cost */, 
		   float ** lrcost /* left-right cost */);
/*< initialize with model size >*/


void dijkstra_close(void);
/*< free allocated storage >*/


void dijkstra_source(int s1, int s2);
/*< initialize source >*/


bool dijskstra_step(int *i1, int *i2, int *ud, int *lr);
/*< one step of the algorithm, true on success >*/


void dijkstra_start(int s1, int s2);
/*< intialize path >*/


bool dijkstra_next(int *ud, int *lr);
/*< find the next shift (up-down, left-right), return true on success >*/


void dijkstra_cost(sf_file out);
/*< write cost function >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _dip3_h
#define _dip3_h


void dip3_init(int m1, int m2, int m3 /* dimensions */, 
	       int* rect              /* smoothing radius [3] */, 
	       int niter              /* number of iterations */,
	       float eps1             /* regularization */,      
	       bool verb              /* verbosity flag */);
/*< initialize >*/


void dip3_close(void);
/*< free allocated storage >*/


void dip3(bool left               /* left or right prediction */,
	  int dip                 /* 1 - inline, 2 - crossline */, 
	  int niter               /* number of nonlinear iterations */, 
	  int nw                  /* filter size */, 
	  int nj                  /* filter stretch for aliasing */, 
	  float *u                /* input data */, 
	  float* p                /* output dip */, 
	  bool* mask              /* input mask for known data */,
	  float pmin, float pmax  /* minimum and maximum dip */);
/*< estimate local dip >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _diplet_h
#define _diplet_h


void diplet_init(int n1      /* trace length */, 
		 int n2      /* number of traces */,
		 int np1     /* number of slopes */,
		 float ***p1 /* slopes */,
		 float ***m1 /* data mask */,
		 bool inv    /* inversion flag */, 
		 float eps   /* regularization parameter */,
		 int order   /* accuracy order */,
		 char type   /* transform type */);
/*< allocate space >*/


void diplet_close(void);
/*< deallocate space >*/


void diplet_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _dips_h
#define _dips_h


void dips_init(int nd1        /* number of dips */, 
	       int nw         /* accuracy order */, 
	       int nj         /* filter stretch for aliasing */, 
	       int nx, int ny /* data dimensions */, 
	       float** x1     /* data [ny][nx] */);
/*< initialize >*/


void dips_close(void);
/*< free allocated storage >*/


void dips(const float *d /* initial dip [nd] */, 
	  float *b       /* right-hand side [nx*ny] */, 
	  float **aa     /* matrix to invert [nx*ny][nd] */);
/*< estimate dips >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _div2_h
#define _div2_h


void div2_init(int n1, int n2     /* data dimensions */, 
	       float f1, float f2 /* smoothing */, 
	       int niter1         /* number of iterations */, 
	       bool gauss1        /* if exact gaussian */,
	       bool verb          /* verbosity flag */);
/*< initialize >*/


void div2_close (void);
/*< free allocated storage >*/


void div2 (float* num, float* den,  float* rat);
/*< smooth division: rat=num/den >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _explanesignoi_h
#define _explanesignoi_h


#include <rsf.h>


void explanesignoi_init (int m1,int m2 /* data size */, 
			 float eps1    /* signal/noise scaling */, 
			 float **aa    /* frequency filter [4][m1*m2] */, 
			 int nw        /* dip filter order */, 
			 int nj1       /* dip filter step for noise */, 
			 int nj2       /* dip filter step for signal */, 
			 float **nn    /* noise dip [m1*m2] */, 
			 float **ss    /* signal dip [m1*m2] */);
/*< initialize >*/


void explanesignoi_close(void);
/*< free allocated storage >*/


void explanesignoi_lop (bool adj, bool add, int ns, int nd, 
			float *ss, float *dat);
/*< linear operator for inversion >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _expont_h
#define _expont_h


#include <rsf.h>


void expont_init(int n1_in,int n2_in /* data size */, 
		 float *a1           /* filter component [n1*n2] */, 
		 float *b1           /* filter component [n1*n2] */);
/*< initialize >*/


void expont_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _expsignoi2_h
#define _expsignoi2_h


#include <rsf.h>


void expsignoi2_init (int m1,int m2 /* data size */, 
		      float eps1    /* signal/noise scaling */, 
		      float **aa    /* frequency filter [4][m1*m2] */);
/*< initialize >*/


void expsignoi2_close(void);
/*< free allocated storage >*/


void expsignoi2_lop (bool adj, bool add, int ns, int nd, 
		     float *sig /* signal */, float *dat /* data */);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _fdip_h
#define _fdip_h


void fdip_init(int m1,int m2,int m3,int *rect, int niter, bool verb);
/*< initialize >*/


void fdip_close();
/*< release work space >*/


void fdip(float *in,float *out, 
	  bool **mask, /* input mask for known data */
	  int dim /* 0 - inline; 1 - xline; X - both*/);
/*< 3D dip estimation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _gauss2_h
#define _gauss2_h


void gauss2_init(int n1, int n2     /* data size */, 
		 float f1, float f2 /* smoothing radius */);
/*< initialize (call freqfilt2 afterwards) >*/


void gauss2_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _int1_h
#define _int1_h


void int1_init (float* coord               /* cooordinates [nd] */, 
		float o1, float d1, int n1 /* axis */,
		int n2                     /* number of slices */,
		sf_interpolator interp     /* interpolation function */, 
		int nf                     /* interpolator length */, 
		int nd_in                  /* number of data points */);
/*< initialize >*/


void int1_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/


void int1_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _int2_h
#define _int2_h


void int2_init (float** coord              /* cooordinates [nd] */, 
		float o1, float o2, 
		float d1, float d2,
		int   n1, int   n2         /* axes */,
		int ns                     /* number of slices */,
		sf_interpolator interp     /* interpolation function */, 
		int nf                     /* interpolator length */, 
		int nd_in                  /* number of data points */);
/*< initialize >*/


void int2_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/


void int2_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mask6_h
#define _mask6_h


#include <rsf.h>


void mask32 (bool both              /* left and right predictions */,
	     int nw                 /* filter size */, 
	     int nj1, int nj2       /* dealiasing stretch */, 
	     int nx, int ny, int nz /* data size */, 
	     float *yy              /* data [nz*ny*nx] */, 
	     bool **m               /* dip mask [both? 4:2][nz*ny*nx] */);
/*< two-dip masks in 3-D >*/


void mask3 (int nw         /* filter size */, 
	    int nj         /* dealiasing stretch */, 
	    int nx, int ny /* data size */, 
	    float **yy     /* data */, 
	    bool **mm      /* mask */);
/*< one-dip mask in 2-D >*/


void mask6 (int nw           /* filter size */, 
	    int nj1, int nj2 /* dealiasing stretch */, 
	    int nx, int ny   /* data size */, 
	    float *yy       /* data [ny][nx] */, 
	    bool *mm        /* mask [ny][nx] */);
/*< two-dip mask in 2-D >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _matmult_h
#define _matmult_h


#include <rsf.h>


void matmult_init (float** bb);
/*< initialize with a pointer to a matrix >*/


void matmult_lop (bool adj, bool add, 
		  int nx, int ny, float* x, float*y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _matrixdivn_h
#define _matrixdivn_h


void matrixdivn_init(int ndim     /* number of dimensions */, 
		     int n        /* data size */, 
		     int *ndat    /* data dimensions [ndim] */, 
		     int *nbox    /* smoothing radius [ndim] */,
		     float** mat  /* matrux [4][nd] */,
		     int niter1   /* number of iterations */,
		     bool verb    /* verbosity flag */);
/*< initialize >*/


void matrixdivn_close (void);
/*< free allocated storage >*/


void matrixdivn (float* dat  /* data */, 
		 float* mod /* model */);
/*< smoothly invert >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _odip2_h
#define _odip2_h


void odip2_init(int m1, int m2 /* dimensions */, 
		int* rect      /* smoothing radius [2] */, 
		int niter      /* number of iterations */,    
		bool verb      /* verbosity flag */);
/*< initialize >*/


void odip2_close(void);
/*< free allocated storage >*/


void odip2(int niter   /* number of nonlinear iterations */, 
	   int nw      /* filter size */, 
	   float *u    /* input data */, 
	   float* p    /* output dips */);
/*< estimate local dip >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _opwd2_h
#define _opwd2_h


typedef struct Omni2 *omni2;
/* abstract data type */


omni2 opwd2_init(int nw               /* filter order */, 
		 int nx, int ny       /* data size */, 
		 float *p1, float *p2 /* dip [ny][nx] */);
/*< Initialize >*/


void opwd2_close(omni2 ap);
/*< free allocated storage >*/


void opwd22_init (omni2 ap1);
/*< Initialize linear operator >*/


void opwd21 (bool der1, bool der2 /* derivative flags */, 
	     const omni2 ap /* OPWD object */, 
	     float* xx     /* input */, 
 	     float* yy     /* output */);
/*< plane-wave destruction >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pbeamform_h
#define _pbeamform_h


#include <rsf.h>


void pbeamform_init(bool gauss1    /* pseudo-gaussian */,
		    int m1, int m2 /* data dimensions */, 
		    int order, 
		    int rect1      /* triangle radius */);
/*< initialize >*/


void pbeamform_set(float** p /* slope [m2][m1] */);
/*< set slopes >*/


void pbeamform_close(void);
/*< free allocated storage >*/


void pbeamform_lop(bool adj, bool add, int nc, int nd, float* c, float* d);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _planesignoi_h
#define _planesignoi_h


#include <rsf.h>


void planesignoi_init (int nw           /* filter size */, 
		       int nj1, int nj2 /* dealiasing stretch */, 
		       int nx, int ny   /* data size */, 
		       float **nn       /* noise slope */, 
		       float **ss       /* signal slope */, 
		       float eps1       /* regularization parameter */);
/*< initialize >*/


void planesignoi_lop (bool adj, bool add, int ns, int nd, float *s, float *d);
/*< linear operator >*/


void planesignoi_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predict_h
#define _predict_h


#include <rsf.h>


void predict_init (int nx, int ny /* data size */, 
		   float e        /* regularization parameter */,
		   int nw         /* accuracy order */,
		   int k          /* radius */,
		   bool two       /* if two predictions */);
/*< initialize >*/


void predict_close (void);
/*< free allocated storage >*/


void predict_step(bool adj            /* adjoint flag */,
		  bool forw           /* forward or backward */, 
		  float* trace        /* input/output trace */,
		  const float* pp    /* slope */);
/*< prediction step >*/


void predict1_step(bool forw      /* forward or backward */, 
		   float* trace1  /* input trace */,
		   const float* pp /* slope */,
		   float* trace /* output trace */);
/*< prediction step from one trace >*/


void predict2_step(bool forw1        /* forward or backward */, 
		   bool forw2,
		   float* trace1     /* input trace */,
		   float* trace2,
		   const float* pp1  /* slope */,
		   const float* pp2,
		   float *trace      /* output trace */);
/*< prediction step from two traces>*/


void predict_set(float **dip1 /* dip field [n2][n1] */);
/*< set the local slopes for applying the linear operator >*/


void predict_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void predicter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void subtracter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void subtract_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predict2_h
#define _predict2_h


void predict2_init(int m1, int m2           /* data dimensions */, 
		   float eps                /* regularization parameter */,
		   int order                /* accuracy order */,
		   float** pp, float **qq   /* slopes [m1][m2] */);
/*< initialize >*/


void predict2_close(void);
/*< free allocated storage >*/


void predict2_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predk_h
#define _predk_h


void predk_init(int nk          /* number of components */,
		int m1, int m2  /* data dimensions */, 
		float eps       /* regularization parameter */,
		int order       /* accuracy order */,
		float*** pk     /* slopes [nk][m1][m2] */);
/*< initialize >*/


void predk_close(void);
/*< free allocated storage >*/


void predk_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwd_h
#define _pwd_h


#include <rsf.h>


typedef struct Pwd *pwd; /* abstract data type */


pwd pwd_init(int n1 /* trace length */, 
	     int nw /* filter order */);
/*< initialize >*/


void pwd_close (pwd w);
/*< free allocated storage >*/


void pwd_define (bool adj        /* adjoint flag */, 
		 pwd w           /* pwd object */, 
		 const float* pp /* slope */, 
		 float* diag     /* defined diagonal */, 
		 float** offd    /* defined off-diagonal */);
/*< fill the matrix >*/


void pwd_set (bool adj   /* adjoint flag */,
	      pwd w      /* pwd object */, 
	      float* inp /* input */, 
	      float* out /* output */, 
	      float* tmp /* temporary storage */);
/*< matrix multiplication >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwdchain_h
#define _pwdchain_h


void pwdchain_init(int n1,
		   int n2     /* data size */, 
		   int nw     /* filter order */,
		   int nc1    /* number of chain elements */,		   
		   float *x1  /* [n] input */,
		   float *pn1 /* [n*nc] dips */,
		   float *xn1 /* [n*(nc-1)] layers */);
/*< initialize >*/


void pwdchain_close(void);
/*< free allocated storage >*/


void pwdchain_apply(const float *x2, float *y);
/*< apply the matrix operator >*/


void pwdchain(float *y);
/*< apply the chain >*/


void pwdchain_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwdsl_h
#define _pwdsl_h


#include <rsf.h>


void pwdsl_init(int n1, int n2       /* data dimensions */,
		int order            /* accuracy order */,
		int rect1, int rect2 /* triangle radius */,
		float eps            /* regularization parameter */);
/*< initialize >*/


void pwdsl_set(float **dip /* local slope */);
/*< set local slope >*/


void pwdsl_close(void);
/*< free allocated storage >*/


void pwdsl_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwsmooth_h
#define _pwsmooth_h


void pwsmooth_init(int ns      /* spray radius */,
		   int m1      /* trace length */,
		   int m2      /* number of traces */,
		   int order   /* PWD order */,
		   float eps   /* regularization */);
/*< initialize >*/


void pwsmooth_set(float **dip /* local slope */);
/*< set local slope >*/


void pwsmooth_close(void);
/*< free allocated storage >*/


void pwsmooth_lop(bool adj, bool add, 
		  int nin, int nout, float* trace, float *smooth);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwsmooth2_h
#define _pwsmooth2_h


void pwsmooth2_init(int ns      /* spray radius */,  
		    int m1      /* trace length */,
		    int m2      /* number of traces */,
		    int order   /* PWD order */,
		    float eps   /* regularization */);
/*< initialize >*/


void pwsmooth2_set(float **dip1 /* local slope 1 */,
		   float **dip2 /* local slope 2 */);
/*< set local slope >*/


void pwsmooth2_close(void);
/*< free allocated storage >*/


void pwsmooth2_lop(bool adj, bool add, 
		  int nin, int nout, float* trace, float *smooth);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwsmooth3_h
#define _pwsmooth3_h


void pwsmooth3_init(int ns1_in      /* spray radius */,
		    int ns2_in      /* spray radius */,
		    int m1          /* trace length */,
		    int m2          /* number of traces */,
		    int m3          /* number of traces */,
		    int order1_in   /* PWD order */,
		    int order2_in   /* PWD order */,
		    float eps_in    /* regularization */,
		    float ****dip   /* local slope */);
/*< initialize >*/


void pwsmooth3_close(void);
/*< free allocated storage >*/


void pwsmooth3_lop(bool adj, bool add, 
		  int nin, int nout, float* trace, float *smooth);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pwspray_h
#define _pwspray_h


int pwspray_init(int nr      /* spray radius */, 
		 int nt      /* trace length */, 
		 int n       /* number of traces */,
		 int order   /* PWD order */,
		 float eps   /* regularization */);
/*< initialize >*/


void pwspray_set(float **dip /* local slope */);
/*< set local slope >*/


void pwspray_close(void);
/*< free allocated storage >*/


void pwspray_lop(bool adj, bool add, int n, int nu, float* u1, float *u);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _repeat2_h
#define _repeat2_h


#include <rsf.h>


void repeat2_init(int m1            /* trace length */, 
		  int m2            /* number of traces */, 
		  sf_operator oper1 /* operator */);
/*< initialize >*/


void repeat2_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< combined linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _seislet_h
#define _seislet_h


void seislet_init(int n1      /* trace length */, 
		  int n2      /* number of traces */, 
		  bool inv1   /* inversion flag */, 
		  bool unit1  /* weighting flag */,
		  float eps   /* regularization parameter */,
		  int order   /* accuracy order */,
		  char type   /* transform type */);
/*< allocate space >*/


void seislet_set(float **dip /* local slope */);
/*< set local slope >*/


void seislet_close(void);
/*< deallocate space >*/


void seislet_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/


void seislet_destruct(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/


void seislet_construct(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _seisletk_h
#define _seisletk_h


void seisletk_init(int nk      /* number of components */,
		   int n1      /* trace length */, 
		   int n2      /* number of traces */, 
		   bool inv    /* inversion flag */, 
		   float eps   /* regularization parameter */,
		   int order   /* accuracy order */,
		   char type   /* transform type */,
		   float*** pk /* slopes [nk][m1][m2] */);
/*< initialize >*/


void seisletk_close(void);
/*< free allocated storage >*/


void seisletk_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _smooth1_h
#define _smooth1_h


void smooth1_init(int n1, int n2     /* data size */,
		  int nc1            /* number of components */,
		  int nb1, int nb2   /* smoothing radius */);
/*< initialize >*/


void smooth1_close (void);
/*< free allocated storage >*/


void smooth1_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< smooth each component >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _smoothpwd_h
#define _smoothpwd_h


void smoothpwd_init(int n1, int n2 /* data size */,
		    float eps      /* PWD regularization */,
		    int order      /* accuracy order */,
		    int rect1      /* vertical smoothing radius */, 
		    float **dip    /* dip field [n2][n1] */);
/*< initialize >*/


void smoothpwd_close(void);
/*< free allocated storage >*/


void smoothpwd(int niter     /* number of iterations */, 
	       int ncycle    /* number of cycles */, 
	       float* weight /* data weighting */, 
	       float* data   /* input data */, 
	       float* der    /* output derivative */,
	       bool verb     /* verbosity flag */,
	       float eps     /* regularization parameter */);
/*< find the derivative >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _smoothshape_h
#define _smoothshape_h


void smoothshape_init(int n1, int n2        /* data size */,
		      int order             /* accuracy order */,
		      int rect1, int rect2  /* smoothing radius */,
		      float lam             /* operator scaling */,
		      float **dip           /* dip field */);
/*< initialize >*/


void smoothshape_close(void);
/*< free allocated storage >*/


void smoothshape(int niter     /* number of iterations */, 
		 float* weight /* data weighting */, 
		 float* data   /* input data */, 
		 float* der    /* output derivative */);
/*< find the derivative >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _trisl_h
#define _trisl_h


#include <rsf.h>


void trisl_init(int m1, int m2       /* data dimensions */, 
		int rect1, int rect2 /* triangle radius */);
/*< initialize >*/


void trisl_set(float** p1 /* slope [m2][m1] */);
/*< set slopes >*/


void trisl_close(void);
/*< free allocated storage >*/


void trisl_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _trislk_h
#define _trislk_h


void trislk_init(int nk               /* number of components */,
		 int m1, int m2       /* data dimensions */, 
		 int rect1, int rect2 /* triangle radius */,
		 float*** pk          /* slopes [nk][m1][m2] */);
/*< initialize >*/


void trislk_close(void);
/*< free allocated storage >*/


void trislk_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _twobytwo_h
#define _twobytwo_h


void twobytwo_init(float **ww);
/*< initialize >*/


void twobytwo_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _twodip2_h
#define _twodip2_h


#include <rsf.h>


void twodip2_init(int nx, int ny     /* data size */, 
		  float fx, float fy /* smoothing radius */, 
		  bool sign1         /* if keep slope signs */,
		  bool gauss         /* Gaussian versus triangle smoothing */,
		  bool verb          /* verbosity flag */,
		  bool both          /* both slopes or one */);
/*< initialize >*/


void twodip2_close(void);
/*< free allocated storage >*/


void twodip2(int niter        /* number of iterations */, 
	     int nw           /* filter order */, 
	     int nj1, int nj2 /* dealisianing stretch */, 
	     bool verb        /* verbosity flag */, 
	     float *u         /* input data */, 
	     float** pq       /* output slopes */, 
	     bool *mask       /* mask for missing data */);
/*< estimate slopes >*/


void otherdip2(int niter        /* number of iterations */, 
	       int nw           /* filter order */, 
	       int nj1, int nj2 /* dealising stretch */, 
	       bool verb        /* verbosity flag */, 
	       float *u         /* input data */, 
	       float** pq       /* output slope */, 
	       bool *mask       /* mask for missing data */);
/*< estimate the second slope only >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _twoplane2_h
#define _twoplane2_h


#include <rsf.h>


void twoplane2_init (int nw_in            /* filter size */, 
		     int nj1, int nj2     /* dealising stretch */, 
		     int nx_in, int ny_in /* data size */,
		     float **pp           /* first slope */, 
		     float **qq           /* second slope */);
/*< initialize >*/


void twoplane2_close(void);
/*< free allocated storage >*/


void twoplane2_lop (bool adj, bool add, int n1, int n2, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _update_h
#define _update_h


void update_init(int m1, int m2 /* dimensions */,
		 float *t       /* [m1,m2] traveltime */);
/*< initialize >*/


void update_close(void);
/*< free allocated storage >*/


unsigned char get_update(int i, bool *up1, bool *up2, int *j);
/*< next update step >*/

#endif
