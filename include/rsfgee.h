/* This file is automatically generated. DO NOT EDIT! */

#ifndef _autocorr_h
#define _autocorr_h


sf_filter autocorr(const sf_filter aa /* input filter */, 
		   float a0        /* input zero lag */, 
		   float *s0       /* output zero lag */, 
		   float eps       /* tolerance for compression */);
/*< Output the autocorrelation (positive side only) of the input filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _bin2_h
#define _bin2_h


void bin2_init(int m1_in, int m2_in      /* model dimensions */, 
	       float o1_in, float d1_in, 
	       float o2_in, float d2_in  /* model grid */, 
	       float **xy_in             /* data coordinates */);
/*< initialization >*/


void bin2_lop (bool adj, bool add, int nm, int nd, float *mm, float *dd);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _bound_h
#define _bound_h


void bound (int dim         /* number of dimensions */, 
	    bool both       /* if both input and output */,
	    const int *nold /* old data coordinates [dim] */, 
	    const int *nd   /* new data coordinates [dim] */, 
	    const int *na   /* filter box size [dim] */, 
	    const sf_filter aa /* helix filter */);
/*< Mark helix filter outputs where input is off data. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _boxfilter_h
#define _boxfilter_h


void box (int dim            /* number of dimaneions */, 
	  const int *nd      /* data size [dim] */, 
	  const int *center  /* filter center [dim] */, 
	  const int *na      /* filter size [dim] */, 
	  const sf_filter aa /* input filter */, 
	  int nc             /* box size */, 
	  float* cube        /* output box [nc] */);
/*< box it >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _chelix_h
#define _chelix_h


typedef struct chelixfilter {
    int     nh;
    sf_complex* flt;
    int*   lag;
    bool*  mis;
} *cfilter;


/*------------------------------------------------------------*/
cfilter allocatechelix( int nh);
/*< allocation >*/


/*------------------------------------------------------------*/
void deallocatechelix( cfilter aa);
/*< deallocation >*/


/*------------------------------------------------------------*/
void displaychelix( cfilter aa);
/*< display filter >*/


void helimakelag(cfilter aa,int nx, int ny);
/*< make lags for a filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _chelicon_h
#define _chelicon_h




void chelicon_init( cfilter bb);
/*<  Initialized with the filter. >*/


void chelicon_lop( bool adj, bool add, 
		   int nx, int ny, sf_complex* xx, sf_complex* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _cicai1_h
#define _cicai1_h


void cicai1_init (int na         /* filter length */, 
		 sf_complex* aa /* filter [na] */, 
		 int lag        /* filter lag (lag=1 is causal) */);
/*< initialize >*/


void cicai1_lop (bool adj, bool add, int nx, int ny, sf_complex* xx, sf_complex* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _ckolmog_h
#define _ckolmog_h


void ckolmog_init(int n1);
/*< initialize with data length >*/


void ckolmog_close(void);
/*< free allocated storage >*/


void ckolmog(float *aut, sf_complex *trace);
/*< convert trace to minimum-phase >*/


void ckolmog2(float *aut, sf_complex *trace);
/*< convert Fourier-domain auto-correlation to minimum-phase >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _compress_h
#define _compress_h


#include <rsf.h>


sf_filter compress( sf_filter aa /* filter */, 
		    float eps    /* threshold */);
/*< return a new filter with coefficients less than eps removed >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _conv_h
#define _conv_h


sf_filter conv(const sf_filter aa, 
	       const sf_filter bb,
               bool one /* include leading one */);
/*< convolve aa and bb >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _cpolydiv_h
#define _cpolydiv_h


#include <rsf.h>


void cpolydiv_init( int nd       /* data size */, 
		   cfilter bb /* filter */);
/*< initialize >*/


void cpolydiv_lop( bool adj, bool add, 
		   int nx, int ny, sf_complex* xx, sf_complex* yy);
/*< linear operator >*/


void cpolydiv_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _createhelix_h
#define _createhelix_h


sf_filter createhelix(int ndim    /* number of dimensions */, 
		      int* nd     /* data size [ndim] */, 
		      int* center /* filter center [ndim] */, 
		      int* gap    /* filter gap [ndim] */, 
		      int* na     /* filter size [ndim] */);
/*< allocate and output a helix filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mshelix_h
#define _mshelix_h


#include <rsf.h>


typedef struct mshelixfilter {
    int nh, ns;
    float* flt;
    int** lag;
    bool** mis;
    sf_filter one;
} *msfilter;


void onescale(int i, msfilter aa);
/*< select one scale from multiple scales >*/


msfilter msallocate(int nh /* filter size */, 
		    int ns /* number of scales */);
/*< allocate filter >*/


void msdeallocate( msfilter aa);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _createmshelix_h
#define _createmshelix_h




msfilter createmshelix(int ndim    /* number of dimensions */, 
		       int* nd     /* data size [ndim] */, 
		       int* center /* filter center [ndim] */, 
		       int* gap    /* filter gap [ndim] */, 
		       int ns      /* number of scales */, 
		       int *jump   /* filter scaling [ns] */, 
		       int* na     /* filter size [ndim] */);
/*< allocate and output a multiscale helix filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nhelix_h
#define _nhelix_h


#include <rsf.h>


typedef struct nhelixfilter {
    int np;    
    sf_filter* hlx;
    bool* mis;
    int *pch;
} *nfilter;


nfilter nallocate(int np   /* number of patches */, 
		  int nd   /* data size */, 
		  int *nh  /* filter size [np] */, 
		  int *pch /* patching [nd] */);
/*< allocate >*/


void ndeallocate(nfilter aa);
/*< free >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _createnhelix_h
#define _createnhelix_h




nfilter createnhelix(int dim     /* number of dimensions */, 
		     int *nd     /* data size [dim] */, 
		     int *center /* filter center [dim] */, 
		     int *gap    /* filter gap [dim] */, 
		     int *na     /* filter size [dim] */, 
		     int *pch    /* patching [product(nd)] */);
/*< allocate and output a non-stationary filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _ctcaf1_h
#define _ctcaf1_h


#include <rsf.h>


void ctcaf1_init(int ny         /* data size */, 
		sf_complex* yy /* data [ny] */);
/*< initialize >*/


void ctcaf1_lop(bool adj, bool add, int nb, int ny, sf_complex *bb, sf_complex *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _deburst_h
#define _deburst_h


#include <rsf.h>


void deburst (int n           /* data length */, 
	      int niter       /* number of iterations */, 
	      sf_weight wght  /* weight operator */, 
	      float eps       /* regularization */, 
	      const float *dd /* input data */, 
	      float *hh       /* output model */);
/*< debursting by optimization >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _fixbad_h
#define _fixbad_h


void fixbad (int niter    /* number of iterations */, 
	     sf_filter aa /* PEF */, 
	     int ny       /* data size */,
	     float *yy    /* in - data, out - deburst */);
/*< find bad data and restore it >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _gradint2_h
#define _gradint2_h


void  gradint2_init (float** coord          /* coordinates [nd][2] */, 
		     float o1, float o2, 
		     float d1, float d2,
		     int   n1, int   n2     /* axes */, 
		     sf_interpolator interp /* interpolation function */, 
		     int nf                 /* interpolator length */, 
		     int nd                 /* number of data points */);
/*< initialize >*/


void gradint2_lop (bool adj, bool add, int nm, int ny, float* x, float* ord);
/*< linear operator >*/


void gradint2_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _hconest_h
#define _hconest_h


#include <rsf.h>


void hconest_init(float *x_in, sf_filter aa_in);
/*< initialize >*/


void hconest_lop(bool adj, bool add, int na, int ny, float *a, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _heldiv_h
#define _heldiv_h


void heldiv_init(int nd /* data size */, sf_filter aa, sf_filter bb);
/*<  Initialized with two filters. >*/


void heldiv_lop(bool adj, bool add, 
		int nx, int ny, float* xx, float*yy);
/*< linear operator >*/


void heldiv_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _heliarr_h
#define _heliarr_h


void heliarr_init (sf_filter a1, sf_filter a2);
/*< initialize >*/


void heliarr_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _helicon_h
#define _helicon_h


void helicon_init( sf_filter bb);
/*<  Initialized with the filter. >*/


void helicon_lop( bool adj, bool add, 
		  int nx, int ny, float* xx, float*yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _helicon2_h
#define _helicon2_h


void helicon2_init(int nd /* data size */,
		   sf_filter bb);
/*<  Initialized with the filter. >*/


void helicon2_lop( bool adj, bool add, 
		   int nx, int ny, float* xx, float*yy);
/*< linear operator >*/


void helicon2_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _helify_h
#define _helify_h


float helify(float a, float b  /* filter coefficients */, 
	     int k2            /* filter breakpoint */,
	     int nf            /* filter size */, 
	     float* f          /* filter */);
/*< Factor an isotropic Laplacian on a helix >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _hipass_h
#define _hipass_h


#include <rsf.h>


void hipass_init (float eps);
/*< initialize >*/


void hipass_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _hshape_h
#define _hshape_h


#include <rsf.h>


void hshape_init( int nd       /* data size */,
		  int ns       /* scaling */,
		  sf_filter ff /* filter */);
/*< initialize >*/


void hshape_lop( bool adj, bool add, 
		 int nx, int ny, float* xx, float*yy);
/*< linear operator >*/


void hshape_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _hypotenusei_h
#define _hypotenusei_h


#include <rsf.h>


void hypotenusei_init(int nt1);
/*< initialize with trace length >*/


void hypotenusei_close(void);
/*< free allocated storage >*/


void hypotenusei_set(float t0 /* time origin */, 
		     float dt /* time sampling */, 
		     float xs /* offset times slowness */);
/*< set up >*/


void hypotenusei_lop(bool adj, bool add, 
		     int n1, int n2, float *zz, float *tt);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _icaf1_h
#define _icaf1_h


void icaf1_init (int ny    /* filter length */, 
		 float* yy /* data [nx] */, 
		 int lag1  /* filter lag (lag=1 is causal) */);
/*< initialize >*/


void icaf1_lop (bool adj, bool add, int nb, int ny, float* bb, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _icai1_h
#define _icai1_h


void icai1_init (int na    /* filter length */, 
		 float* aa /* filter [na] */, 
		 int lag1  /* filter lag (lag=1 is causal) */);
/*< initialize >*/


void icai1_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _imospray_h
#define _imospray_h


#include <rsf.h>


void imospray_init (float slow /* slowness */, 
		    float y0   /* offset origin */, 
		    float dy   /* offset sampling */, 
		    float z0   /* time origin */, 
		    float dz   /* time sampling */, 
		    int nz     /* time samples */, 
		    int ny     /* offset samples */);
/*< initialize >*/


void imospray_lop(bool adj, bool add, int n1, int n2, 
		  float *stack, float *gather);
/*< linear operator >*/


void imospray_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _invint1_h
#define _invint1_h


void invint1(int niter                  /* number of iterations */,
	     int nd                     /* data size */,
	     float *coord               /* data coordinates */, 
	     const float *dd            /* data values */, 
	     int n1, float o1, float d1 /* model grid */, 
	     int na, const float *aa    /* filter */, 
	     float *mm                  /* estimated model */, 
	     float eps                  /* regularization */);
/*< inverse interpolation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _invstack_h
#define _invstack_h

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _kirchfast_h
#define _kirchfast_h

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _kirchslow_h
#define _kirchslow_h

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _kolmog_h
#define _kolmog_h


void kolmog_init(int n1, int lag1, int shift1);
/*< initialize with data length >*/


void kolmog_close(void);
/*< free allocated storage >*/


void kolmog(float *trace);
/*< convert trace to minimum-phase >*/


void kolmog2(float *trace);
/*< convert Fourier-domain auto-correlation to minimum-phase >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _lace_h
#define _lace_h


sf_filter lace_pef(int dim     /* number of dimensions */, 
		   float *dd   /* data */, 
		   int jump    /* filter stretch */, 
		   int n       /* data size */, 
		   int *nd     /* data dimensions [dim] */, 
		   int *center /* filter center [dim] */, 
		   int *gap    /* filter gap [dim] */, 
		   int *na     /* filter size [dim] */);
/*< estimate PEF >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _laplacian_h
#define _laplacian_h


void laplacian_init(int type1          /* operator type */,
		    int nz, int nx     /* dimensions */,
		    float dz, float dx /* sampling */,
		    float **vt1 /* [nx][nz] (v*t)^2 */);
/*< initialize >*/


void laplacian_close(void);
/*< free allocated storage >*/


void laplacian(float **uin  /* [nx][nz] */, 
	       float **uout /* [nx][nz] */);
/*< apply >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _levint_h
#define _levint_h


void levint1 (int niter       /* number of iterations */, 
	      int nm          /* model size */, 
	      int nr          /* model size + filter size */, 
	      int nd          /* data size */, 
	      float *coord    /* data coordinates [nd] */, 
	      const float *dd /* data [nd] */, 
	      float o1        /* model origin */, 
	      float d1        /* model sampling */, 
	      float *rr       /* initial model + filter [nr] */, 
	      float eps       /* regularization scaling */);
/*< interpolate >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _lint1_h
#define _lint1_h


#include <rsf.h>


void lint1_init (float o1_in, float d1_in /* regular axis sampling */, 
		 const float *coord_in    /* irregular coordinates */);
/*< initialize >*/


void lint1_lop  (bool adj, bool add, int nm, int nd, float *mm, float *dd);
/*< linear interpolation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _lint2_h
#define _lint2_h


void lint2_init( int n1, float o1, float d1 /* first grid axis */, 
		 int n2, float o2, float d2 /* second grid axis */, 
		 float* x, float* y         /* coordinates */);
/*< initialize >*/


void lint2_lop( bool adj, bool add, int nm, int nd, float* mm, float*dd);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _loconvol_h
#define _loconvol_h


#include <rsf.h>


void loconvol_init(sf_filter aa_in);
/*< initialize with the first filter >*/


void loconvol_lop(bool adj, bool add, int nx, int ny, 
		  float *xx, float *yy);
/*< convolve >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _lopef_h
#define _lopef_h


void find_lopef(int dim      /* number of dimensions */, 
		float *wall  /* whole data */, 
		sf_filter aa /* PEF */, 
		int *npatch  /* number of patches [dim] */, 
		int *nwall   /* data size [dim] */, 
		int *nwind   /* patch size [dim] */, 
		float *mask  /* mask for known data */);
/*< estimate local PEF >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mask2i_h
#define _mask2i_h


void maski (int niter       /* number of iterations */, 
	    int nx          /* data size */, 
	    const float *dd /* data */, 
	    float *xx       /* model */, 
	    int *known      /* mask for known data */, 
	    sf_filter aa1   /* first PEF */, 
	    sf_filter aa2   /* second PEF */);
/*< interpolate >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mis1_h
#define _mis1_h


#include <rsf.h>


void mis1_init(int n1    /* data length */, 
	       int na    /* filter length */, 
	       float *aa /* filter [na] */);
/*< initialize >*/


void mis1_close(void);
/*< free allocated storage >*/


void mis1(int niter         /* number of iterations */, 
	  float *xx         /* data/model */, 
	  const bool *known /* mask for known data */,
	  const char *step  /* solver */);
/*< interpolate >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mis2_h
#define _mis2_h


void mis2(int niter         /* number of iterations */, 
	  int nx            /* model size */, 
	  float *xx         /* model */, 
	  sf_filter aa      /* helix filter */, 
	  const bool *known /* mask for known data */,
	  float eps         /* regularization parameter */,
	  bool doprec       /* to apply preconditioning */);
/*< interpolate >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _misif_h
#define _misif_h


#include <rsf.h>


void misif1 (int niter /* number of iterations */, 
	     int na    /* filter length */, 
	     int nx    /* data length */, 
	     float *xx /* data */, 
	     float *aa /* filter */, 
	     bool *mm  /* mask for knowh data */);
/*< interpolate >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _misinput_h
#define _misinput_h


void find_mask(int n            /* data size */, 
	       const int *known /* mask for known data [n] */, 
	       sf_filter aa     /* helical filter */);
/*< create a filter mask >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mkwallwt_h
#define _mkwallwt_h


void mkwallwt(int dim     /* number of dimensions */, 
	      int* npatch /* number of patches [dim] */, 
	      int* nwall  /* data size [dim] */, 
	      int* nwind  /* patch size [dim] */, 
	      float* windwt /* window weighting (input) */, 
	      float* wallwt /* wall weighting (output) */);
/*< make wall weight >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mshconest_h
#define _mshconest_h


#include <rsf.h>




void mshconest_init(float *x, msfilter msaa_in);
/*< initialize with data and filter >*/


void mshconest_lop(bool adj, bool add, int na, int ny, float *a, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mshelicon_h
#define _mshelicon_h


#include <rsf.h>




void mshelicon_init( msfilter bb);
/*< initialize with the filter >*/


void mshelicon_lop( bool adj, bool add, int nx, int ny, float* xx, float*yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _msmis2_h
#define _msmis2_h


#include <rsf.h>




void msmis2(int niter         /* number of iterations */, 
	    int nx            /* data size */, 
	    int ns            /* number of scales */, 
	    float *xx         /* data */, 
	    msfilter aa       /* filter */, 
	    const bool *known /* mask for known data */);
/*< interpolate >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _mspef_h
#define _mspef_h




void msfind_pef(int nd      /* data size */, 
		float* dd   /* data */, 
		msfilter aa /* estimated filter */, 
		int niter   /* number of iterations */);
/*< estimate PEF >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nbound_h
#define _nbound_h




void nbound (int ip     /* patch number */, 
	     int dim    /* number of dimensions */, 
	     int *nd    /* data size [dim] */, 
	     int *na    /* filter size [dim] */, 
	     nfilter aa /* filter */);
/*< define boundaries >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nhconest_h
#define _nhconest_h


#include <rsf.h>




void nhconest_init(float *x_in   /* data */, 
		   nfilter aa_in /* filter */, 
		   int nhmax_in  /* maximum filter size */);
/*< initialize >*/


void nhconest_lop(bool adj, bool add, int naa, int ny, float *a, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nhelicon_h
#define _nhelicon_h


#include <rsf.h>




void nhelicon_init(nfilter aa_in);
/*< initialize with the filter >*/


void nhelicon_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nmis2_h
#define _nmis2_h




void nmis2( int niter        /* number of iterations */, 
	    int nx           /* data size */,
	    float *xx        /* in - data with holes, out - filled */, 
	    const nfilter aa /* filter */, 
	    bool *known      /* mask for known data */, 
	    bool precon      /* whether to use preconditioning */);
/*< fill missing data >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nmisinput_h
#define _nmisinput_h




void nfind_mask(int nd           /* data size */, 
		const int *known /* mask for known data [nd] */, 
		nfilter aa       /* filter */);
/*< find mask >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nmo0_h
#define _nmo0_h


void nmo0_init(float *slow_in /* slowness */,
	       int n_in,
	       float t0_in,
	       float dt_in    /* time axis */);
/*< initialize >*/


void nmo0_set(float x_in /* offset */);
/*< set offset >*/


void nmo0_lop(bool adj, bool add, int nz, int nt, float *zz,  float *tt);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _nmo1_h
#define _nmo1_h


void nmo1_init(float *slow_in /* slowness */,
	       int n_in,
	       float t0_in,
	       float dt_in    /* time axis */);
/*< initialize >*/


void nmo1_set(float x_in /* offset */);
/*< set offset >*/


void nmo1_lop(bool adj, bool add, int nz, int nt, float *zz,  float *tt);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _npef_h
#define _npef_h




void nfind_pef(int nd     /* data size */, 
	       float *dd  /* data */, 
	       nfilter aa /* estimated filter */, 
	       nfilter rr /* regularization filter */, 
	       int niter  /* number of iterations */, 
	       float eps  /* regularization parameter */, 
	       int nh     /* filter size */);
/*< estimate non-stationary PEF >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _npfactor_h
#define _npfactor_h


nfilter npfactor(int npx, int npy /* number of slopes */,
		 const int *n     /* [3] data size */, 
		 const int *m     /* [3] patch size */,
		 const float *pp  /* inline slope */,
                 const float *qq  /* crossline slope */,
		 int niter        /* number of iterations */,
                 float eps        /* compression tolerance */);
/*< create a filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _npolydiv_h
#define _npolydiv_h


#include <rsf.h>




void npolydiv_init (int nd_in     /* data size */, 
		    nfilter aa_in /* filter */);
/*< initialize >*/


void npolydiv_close(void);
/*< free allocated storage >*/


void npolydiv_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _npolydiv2_h
#define _npolydiv2_h


#include <rsf.h>




void npolydiv2_init (int nd     /* data size */, 
		     nfilter aa /* non-stationary filter */);
/*< initialize >*/


void npolydiv2_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void npolydiv2_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _parcel_h
#define _parcel_h


#include <rsf.h>


void parcel_init(int dim /* number of dimensions */, 
		 int *npatch /* number of patches [dim] */, 
		 int *nwall  /* data size [dim] */, 
		 int *nwind  /* patch size [dim] */);
/*< initialize >*/


void parcel_lop(bool adj, bool add, int n, int mw, float* wall, float* wind);
/*< parcel operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _patch_h
#define _patch_h


#include <rsf.h>


void patch_init(int dim_in     /* number of dimensions */, 
		int* npatch_in /* number of patches [dim] */, 
		int* nwall_in  /* data size [dim] */, 
		int* nwind_in  /* patch size [dim] */);
/*< initialize >*/


void patch_lop (bool adj, bool add, int nx, int ny, 
		float* wall, float* wind);
/*< patch operator >*/


void patch_close(void);
/*< Move to next patch. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _patching_h
#define _patching_h


#include <rsf.h>


void patching(sf_operator oper /* operator */, 
	      float* modl      /* input */, 
	      float* data      /* output */, 
	      int dim          /* number of dimensions */, 
	      int* npatch      /* number of patches [dim] */, 
	      int* nwall       /* data size [dim] */, 
	      int* nwind       /* patch size [dim] */, 
	      float* windwt    /* window weight */);
/*< patch an operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pef_h
#define _pef_h


void find_pef(int nd       /* data size */, 
	      float* dd    /* data [nd] */, 
	      sf_filter aa /* estimated filter */, 
	      int niter    /* number of iterations */);
/*< find PEF >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pefest_h
#define _pefest_h


void pefest(int niter    /* number of iterations */,
	    int ny       /* data size */,
	    float *yy    /* input data */, 
	    sf_filter aa /* estimated PEF */);
/*< estimate PEF avoiding zeros and bursty noise >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pefhel_h
#define _pefhel_h


void pefhel_init (sf_filter aa /* PEF */, 
		  int ny       /* data size */,
		  float *yy    /* data */);
/*< initialize >*/


void pefhel_lop(bool adj, bool add, int nx, int nr, float *x, float *r);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _peftc_h
#define _peftc_h


#include <rsf.h>


void peftc_init (int na    /* filter length */, 
		 int ny    /* data length */, 
		 float *aa /* filter [na] */, 
		 float *yy /* data [ny] */);
/*< initialize >*/


void peftc_lop (bool adj, bool add, int nx, int nr, float *x, float *r);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _pfactor_h
#define _pfactor_h


void pfactor_init(int nt1, int nx1 /* data size */);
/*< initialize >*/


void pfactor_close(void);
/*< free allocated storage >*/


sf_filter pfactor(int na     /* filter size */,
		  float p    /* inline slope */,
		  float q    /* crossline slope */,
		  int niter  /* number of iterations */,
		  float eps  /* compression tolerance */,
		  bool fixed /* if fixed size */,
		  bool verb  /* verbosity */,
		  float *a0  /* zero-lag coefficient */);
/*< find a filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _printfilter_h
#define _printfilter_h


void print (int dim            /* number of dimensions */, 
	    const int *nd      /* data size [dim] */, 
	    const int *center  /* filter center [dim] */, 
	    const int *na      /* filter size [dim] */, 
	    const sf_filter aa /* filter to print */);
/*< print a filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _random_h
#define _random_h


void random_init (int iseed);
/*< initialize the seed >*/


float random0 (void);
/*< get a random number between 0 and 1 >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _regrid_h
#define _regrid_h


void regrid( int dim         /* number of dimensions */, 
	     const int* nold /* old data size [dim] */, 
	     const int* nnew /* new data size [dim] */, 
	     sf_filter aa    /* modified filter */);
/*< change data size >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _scaletrace_h
#define _scaletrace_h


void scaletrace_init(int n1_in, int n2_in, const float *data_in);
/*< initialize >*/


void scaletrace_lop(bool adj, bool add, int ns, int nd, 
		    float *scale, float *sdata);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _signoi_h
#define _signoi_h


#include <rsf.h>


void signoi_init(sf_filter nn_in /* noise PEF */, 
		 sf_filter ss_in /* signal PEF */, 
		 int niter_in    /* number of iterations */, 
		 int nd_in       /* data size */, 
		 float eps_in    /* regularization parameter (signal/noise) */,
		 bool verb_in    /* verbosity flag */);
/*< initialize >*/


void signoi_lop (bool adj, bool add, int n1, int n2, 
		 float *data, float *sign);
/*< linear operator >*/


void signoi2_lop (bool adj, bool add, int n1, int n2, 
		 float *data, float *sign);
/*< alternative linear operator >*/


void signoi1_lop (bool adj, bool add, int n1, int n2, 
		 float *data, float *sign);
/*< alternative linear operator >*/


void signoi3_lop (bool adj, bool add, int n1, int n2, 
		 float *data, float *sign);
/*< alternative linear operator >*/


void signoi_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _spraysum_h
#define _spraysum_h


void spraysum_init(int n1_in, int n2_in, int n3_in, 
		   int m1_in, int m2_in, int m3_in);
/*< initialize >*/


void spraysum_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _stack0_h
#define _stack0_h


void stack0_init(float *slow  /* slowness */,
		 int nt_in,
		 float t0,
		 float dt     /* time axis */,
		 int nx_in,
		 float x0_in,
		 float dx_in  /* offset axis */);
/*< initialize >*/


void stack0_lop(bool adj, bool add, int ns, int ng, 
		float *stack, float *gather);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _steepdip_h
#define _steepdip_h


sf_filter steep(int dim    /* number of dimensions */, 
		int *n     /* data size [dim] */, 
		int *a     /* filter size [dim] */, 
		float *d   /* axis sampling [dim] */, 
		float vel  /* velocity */, 
		float tgap /* time gap */);
/*< define PEF >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _tcaf1_h
#define _tcaf1_h


#include <rsf.h>


void tcaf1_init(int ny    /* data size */, 
		float* yy /* data [ny] */);
/*< initialize >*/


void tcaf1_lop(bool adj, bool add, int nb, int ny, float *bb, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _tcai1_h
#define _tcai1_h


#include <rsf.h>


void tcai1_init (int na          /* filter size */, 
		 const float* aa /* filter [na] */);
/*< initialize >*/


void tcai1_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _tcai2_h
#define _tcai2_h


#include <rsf.h>


void tcai2_init (int na    /* filter size */, 
		 int nx    /* data size */, 
		 float *aa /* filter [n1] */);
/*< initialize >*/


void tcai2_lop (bool adj, bool add, int nx, int nr, float *x, float *r);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _tent_h
#define _tent_h


void tent (int dim           /* number of dimensions */, 
	   const int* nwind  /* window size [dim] */, 
	   const int* center /* filter center [dim] */, 
	   const int* a      /* filter size [dim] */, 
	   float* windwt     /* output weight */);
/*< compute weight >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _unwrap_h
#define _unwrap_h


void grad2init(int n1, int n2, 
	       sf_complex **z, float ***rt);
/*< initialize phase gradient >*/


void unwraper(int n1, int n2, /* dimensions */
	      sf_complex **zz /* input data */, 
	      float *hh       /* phase */, 
	      int niter       /* number of iterations */);
/*< Phase unwraper.   Starting from phase hh, improve it. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _velcon3_h
#define _velcon3_h


void velcon3_init (int inv1, float w1, float w2, float d0, 
		   int mt, int mx, int my, int mv, float dd, float dx);
/*< initialize >*/


void velcon3_apply (bool adj, float **p1, float **p2);
/*< apply >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _wilson_h
#define _wilson_h


#include <rsf.h>


void wilson_init( int nmax /* maximum data size */);
/*< initialize >*/


float wilson_factor(int niter    /* number of iterations */, 
		    float s0     /* zero-lag auto-correlation */, 
		    sf_filter ss /* input auto-correlation */, 
		    sf_filter aa /* output factor */, 
		    bool verb    /* verbosity flag */,
		    float tol    /* tolerance */);
/*< Factor >*/


void wilson_close( void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _wilson2_h
#define _wilson2_h


#include <rsf.h>


void wilson2_init(int nmax /* maximum data size */);
/*< initialize >*/


float wilson2_factor(int niter   /* number of iterations */, 
		    float s0     /* zero-lag auto-correlation */, 
		    sf_filter ss /* input auto-correlation */, 
		    float a0     /* zero-lag filter */,
		    sf_filter aa /* output factor */, 
		    bool verb    /* verbosity flag */,
		    float tol    /* tolerance */);
/*< Factor >*/


void wilson2_close( void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _xkolmog_h
#define _xkolmog_h




int xkolmog_init(int n1);
/*< initialize with data length >*/


void xkolmog_close(void);
/*< free allocated storage >*/


void xkolmog(sf_complex *trace1, sf_complex *trace2);
/*< convert Fourier-domain cross-correlation to minimum-phase >*/


void xkolmog_helix(cfilter cross, cfilter fac1, cfilter fac2);
/*< Helix filter factorization >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _xtomo_h
#define _xtomo_h


void xtomo_init(float oz1, float dz1, 
		float ox1, float dx1, 
		float oh1, float dh1,
		float oy1, float dy1,
		int nt1, int nz1, int nx1, int nh1, int ny1);
/*< initialize with domensions >*/


void xtomo_lop(bool adj, bool add, int nm, int nd, float *modl, float *data);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _zpad1_h
#define _zpad1_h

#endif
