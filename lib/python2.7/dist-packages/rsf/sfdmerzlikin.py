import rsf.doc

sfgpi3dzo = rsf.doc.rsfprog('sfgpi3dzo','user/dmerzlikin/Mgpi3dzo.c','''Gaussian weighting for ZO 3D case''')
sfgpi3dzo.par('v_a',rsf.doc.rsfpar('float','','',''''''))
sfgpi3dzo.par('v_b',rsf.doc.rsfpar('float','','',''''''))
sfgpi3dzo.par('beta',rsf.doc.rsfpar('float','0.0','',''''''))
sfgpi3dzo.par('eps',rsf.doc.rsfpar('float','0.001','',''''''))
sfgpi3dzo.version('2.1-git')
sfgpi3dzo.synopsis('''sfgpi3dzo < inp.rsf > out.rsf v_a= v_b= beta=0.0 eps=0.001''','''''')
rsf.doc.progs['sfgpi3dzo']=sfgpi3dzo

sfpsovc = rsf.doc.rsfprog('sfpsovc','user/dmerzlikin/Mpsovc.c','''Pre-stack 2-D oriented velocity continuation. ''')
sfpsovc.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sfpsovc.par('nv',rsf.doc.rsfpar('int','','','''velocity steps '''))
sfpsovc.par('dv',rsf.doc.rsfpar('float','','','''velocity step size '''))
sfpsovc.par('v0',rsf.doc.rsfpar('float','','','''starting velocity '''))
sfpsovc.version('2.1-git')
sfpsovc.synopsis('''sfpsovc < in.rsf > out.rsf verb=y nv= dv= v0=''','''
Axes: (Omega,h,p,k) -> (Omega,v,p,k)

Make sure you use half-offsets for h.

''')
rsf.doc.progs['sfpsovc']=sfpsovc

sfpsovcp = rsf.doc.rsfprog('sfpsovcp','user/dmerzlikin/Mpsovcp.c','''Pre-stack 2-D oriented velocity continuation. ''')
sfpsovcp.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sfpsovcp.par('nv',rsf.doc.rsfpar('int','','','''velocity steps '''))
sfpsovcp.par('dv',rsf.doc.rsfpar('float','','','''velocity step size '''))
sfpsovcp.par('v0',rsf.doc.rsfpar('float','','','''starting velocity '''))
sfpsovcp.version('2.1-git')
sfpsovcp.synopsis('''sfpsovcp < in.rsf > out.rsf verb=y nv= dv= v0=''','''
Axes: (Omega,h,k,p) -> (Omega,v,k,p)

Make sure you use half-offsets for h.

''')
rsf.doc.progs['sfpsovcp']=sfpsovcp

sfflatlinpiwrapper = rsf.doc.rsfprog('sfflatlinpiwrapper','user/dmerzlikin/Mflatlinpiwrapper.c','''pi operator building wrapping test function flat gaussian weighting smoothing after pi''')
sfflatlinpiwrapper.par('pifk',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfflatlinpiwrapper.par('velocity',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfflatlinpiwrapper.par('hd',rsf.doc.rsfpar('bool','y','',''''''))
sfflatlinpiwrapper.par('domod',rsf.doc.rsfpar('bool','y','','''if y, apply half-derivative filter '''))
sfflatlinpiwrapper.par('sw',rsf.doc.rsfpar('int','0','','''if > 0, select a branch of the antialiasing operation '''))
sfflatlinpiwrapper.par('adj',rsf.doc.rsfpar('bool','n','','''if perform derivative filtering '''))
sfflatlinpiwrapper.par('sm',rsf.doc.rsfpar('bool','y','','''if y, do adjoint integration '''))
sfflatlinpiwrapper.par('v_1',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper.par('passthr',rsf.doc.rsfpar('float','0.001','',''''''))
sfflatlinpiwrapper.par('eps',rsf.doc.rsfpar('float','0.001','',''''''))
sfflatlinpiwrapper.par('epst2',rsf.doc.rsfpar('float','0.001','',''''''))
sfflatlinpiwrapper.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sfflatlinpiwrapper.par('repeat',rsf.doc.rsfpar('int','1','','''repeat filtering several times '''))
sfflatlinpiwrapper.par('v0',rsf.doc.rsfpar('float','','','''constant velocity (if no velocity=) '''))
sfflatlinpiwrapper.par('rect#',rsf.doc.rsfpar('int','(1,1,...)','','''smoothing radius on #-th axis '''))
sfflatlinpiwrapper.par('diff#',rsf.doc.rsfpar('bool','(n,n,...)','','''differentiation on #-th axis '''))
sfflatlinpiwrapper.par('pifk',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfflatlinpiwrapper.par('velocity',rsf.doc.rsfpar('string ',desc='''velocity file (auxiliary input file name)'''))
sfflatlinpiwrapper.version('2.1-git')
sfflatlinpiwrapper.synopsis('''sfflatlinpiwrapper < inp.rsf > out.rsf pifk=pifk.rsf velocity=vel.rsf hd=y domod=y sw=0 adj=n sm=y v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt repeat=1 v0= rect#=(1,1,...) diff#=(n,n,...)''','''''')
rsf.doc.progs['sfflatlinpiwrapper']=sfflatlinpiwrapper

sfflatlinpiwrapper2d = rsf.doc.rsfprog('sfflatlinpiwrapper2d','user/dmerzlikin/Mflatlinpiwrapper2d.c','''pi operator building wrapping test function flat gaussian weighting smoothing after pi''')
sfflatlinpiwrapper2d.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfflatlinpiwrapper2d.par('gather',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfflatlinpiwrapper2d.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfflatlinpiwrapper2d.par('pifk',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfflatlinpiwrapper2d.par('adj',rsf.doc.rsfpar('bool','n','','''kirchhoff parameters '''))
sfflatlinpiwrapper2d.par('normalize',rsf.doc.rsfpar('bool','y','','''normalize for the fold '''))
sfflatlinpiwrapper2d.par('nh',rsf.doc.rsfpar('int','','','''number of offsets (for modeling) '''))
sfflatlinpiwrapper2d.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sfflatlinpiwrapper2d.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sfflatlinpiwrapper2d.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sfflatlinpiwrapper2d.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sfflatlinpiwrapper2d.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sfflatlinpiwrapper2d.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sfflatlinpiwrapper2d.par('dh',rsf.doc.rsfpar('float','','','''offset sampling (for modeling) '''))
sfflatlinpiwrapper2d.par('h0',rsf.doc.rsfpar('float','','','''first offset (for modeling) '''))
sfflatlinpiwrapper2d.par('sm',rsf.doc.rsfpar('bool','y','','''if y, do adjoint integration '''))
sfflatlinpiwrapper2d.par('v_1',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper2d.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper2d.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper2d.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sfflatlinpiwrapper2d.par('passthr',rsf.doc.rsfpar('float','0.001','',''''''))
sfflatlinpiwrapper2d.par('eps',rsf.doc.rsfpar('float','0.001','',''''''))
sfflatlinpiwrapper2d.par('epst2',rsf.doc.rsfpar('float','0.001','',''''''))
sfflatlinpiwrapper2d.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sfflatlinpiwrapper2d.par('repeat',rsf.doc.rsfpar('int','1','','''repeat filtering several times '''))
sfflatlinpiwrapper2d.par('domod',rsf.doc.rsfpar('bool','y','',''''''))
sfflatlinpiwrapper2d.par('rect#',rsf.doc.rsfpar('int','(1,1,...)','','''smoothing radius on #-th axis '''))
sfflatlinpiwrapper2d.par('diff#',rsf.doc.rsfpar('bool','(n,n,...)','','''differentiation on #-th axis '''))
sfflatlinpiwrapper2d.par('gather',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfflatlinpiwrapper2d.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sfflatlinpiwrapper2d.par('pifk',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfflatlinpiwrapper2d.version('2.1-git')
sfflatlinpiwrapper2d.synopsis('''sfflatlinpiwrapper2d < inp.rsf > out.rsf vel=vel.rsf gather=gather.rsf offset=offset.rsf pifk=pifk.rsf adj=n normalize=y nh= antialias=1.0 apt=nx angle=90.0 half=y verb=y rho=1.-1./nt dh= h0= sm=y v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt repeat=1 domod=y rect#=(1,1,...) diff#=(n,n,...)''','''''')
rsf.doc.progs['sfflatlinpiwrapper2d']=sfflatlinpiwrapper2d

sfchaindr = rsf.doc.rsfprog('sfchaindr','user/dmerzlikin/Mchaindr.c','''chain diffraction extraction debug version''')
sfchaindr.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfchaindr.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfchaindr.par('dipim',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfchaindr.par('diffmod',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfchaindr.par('outpwd',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfchaindr.par('outdip',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfchaindr.par('gather',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfchaindr.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfchaindr.par('adj',rsf.doc.rsfpar('bool','n','','''if perform derivative filtering = PWD '''))
sfchaindr.par('sm',rsf.doc.rsfpar('bool','y','','''if perform modelling via Kirchhoff '''))
sfchaindr.par('domod',rsf.doc.rsfpar('bool','y','','''get regularization parameter '''))
sfchaindr.par('reg',rsf.doc.rsfpar('float','0.0','','''debug flag '''))
sfchaindr.par('debug',rsf.doc.rsfpar('bool','','',''''''))
sfchaindr.par('normalize',rsf.doc.rsfpar('bool','y','','''normalize for the fold '''))
sfchaindr.par('nh',rsf.doc.rsfpar('int','','','''number of offsets (for modeling) '''))
sfchaindr.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sfchaindr.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sfchaindr.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sfchaindr.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sfchaindr.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sfchaindr.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sfchaindr.par('dh',rsf.doc.rsfpar('float','','','''offset sampling (for modeling) '''))
sfchaindr.par('h0',rsf.doc.rsfpar('float','','','''first offset (for modeling) '''))
sfchaindr.par('v_1',rsf.doc.rsfpar('float','','',''''''))
sfchaindr.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sfchaindr.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sfchaindr.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sfchaindr.par('passthr',rsf.doc.rsfpar('float','0.001','',''''''))
sfchaindr.par('eps',rsf.doc.rsfpar('float','0.001','',''''''))
sfchaindr.par('epst2',rsf.doc.rsfpar('float','0.001','',''''''))
sfchaindr.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sfchaindr.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sfchaindr.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing '''))
sfchaindr.par('gather',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfchaindr.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sfchaindr.version('2.1-git')
sfchaindr.synopsis('''sfchaindr < inp.rsf > out.rsf vel=vel.rsf dip=dip.rsf dipim=dipim.rsf diffmod=diffmod.rsf outpwd=outpwdcheck.rsf outdip=outdipcheck.rsf gather=gather.rsf offset=offset.rsf adj=n sm=y domod=y reg=0.0 debug= normalize=y nh= antialias=1.0 apt=nx angle=90.0 half=y verb=y rho=1.-1./nt dh= h0= v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt order=1 nj1=1''','''''')
rsf.doc.progs['sfchaindr']=sfchaindr

sfanovc = rsf.doc.rsfprog('sfanovc','user/dmerzlikin/Manovc.c','''Oriented anisotropy continuation: shifted hyperbola travel-time approximation. ''')
sfanovc.par('eps',rsf.doc.rsfpar('float','0.1','','''stretch regularization '''))
sfanovc.par('nv',rsf.doc.rsfpar('int','1','','''number of velocity steps '''))
sfanovc.par('lagrange',rsf.doc.rsfpar('bool','n','','''Use Lagrangian method '''))
sfanovc.par('plus',rsf.doc.rsfpar('bool','y','','''Plus or minus in coefficients: I have two versions '''))
sfanovc.par('debug',rsf.doc.rsfpar('bool','y','','''Implement debugger: add it later '''))
sfanovc.par('isotr',rsf.doc.rsfpar('bool','n','','''Implement debugger: add it later '''))
sfanovc.par('testwarp',rsf.doc.rsfpar('bool','n','','''Implement debugger: add it later '''))
sfanovc.par('full',rsf.doc.rsfpar('bool','n','','''full accuracy flag - considers all (s-1) terms in any power '''))
sfanovc.par('v0',rsf.doc.rsfpar('float','','',''''''))
sfanovc.par('ns',rsf.doc.rsfpar('int','1','','''s steps '''))
sfanovc.par('ds',rsf.doc.rsfpar('float','','','''s step size '''))
sfanovc.par('s0',rsf.doc.rsfpar('float','','',''''''))
sfanovc.par('smax',rsf.doc.rsfpar('float','','',''''''))
sfanovc.par('epsr',rsf.doc.rsfpar('float','0.001','','''damper for root '''))
sfanovc.par('s0',rsf.doc.rsfpar('float','','','''start '''))
sfanovc.version('2.1-git')
sfanovc.synopsis('''sfanovc < in.rsf > out.rsf eps=0.1 nv=1 lagrange=n plus=y debug=y isotr=n testwarp=n full=n v0= ns=1 ds= s0= smax= epsr=0.001 s0=''','''
Axis order: t, p, x
''')
rsf.doc.progs['sfanovc']=sfanovc

sfanovcv = rsf.doc.rsfprog('sfanovcv','user/dmerzlikin/Manovcv.c','''Oriented anisotropy continuation: shifted hyperbola travel-time approximation. ''')
sfanovcv.par('velocity',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfanovcv.par('kappa1',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfanovcv.par('kappa2',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfanovcv.par('kappa3',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfanovcv.par('rootin',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfanovcv.par('eps',rsf.doc.rsfpar('float','0.1','','''stretch regularization '''))
sfanovcv.par('clip',rsf.doc.rsfpar('float','0.5','','''maximum stretch '''))
sfanovcv.par('windowtime',rsf.doc.rsfpar('float','t0 + (nt-1.0)*dt','','''maximum time 2 consider '''))
sfanovcv.par('nv',rsf.doc.rsfpar('int','1','','''number of velocity steps '''))
sfanovcv.par('lagrange',rsf.doc.rsfpar('bool','n','','''Use Lagrangian method '''))
sfanovcv.par('plus',rsf.doc.rsfpar('bool','y','','''Plus or minus in coefficients: I have two versions '''))
sfanovcv.par('debug',rsf.doc.rsfpar('bool','y','','''Implement debugger: add it later '''))
sfanovcv.par('isotr',rsf.doc.rsfpar('bool','n','','''Implement debugger: add it later '''))
sfanovcv.par('testwarp',rsf.doc.rsfpar('bool','n','','''Implement debugger: add it later '''))
sfanovcv.par('full',rsf.doc.rsfpar('bool','n','','''full accuracy flag - considers all (s-1) terms in any power '''))
sfanovcv.par('v0',rsf.doc.rsfpar('float','','',''''''))
sfanovcv.par('v0',rsf.doc.rsfpar('float','','','''constant velocity (if no velocity=) '''))
sfanovcv.par('ns',rsf.doc.rsfpar('int','1','','''s steps '''))
sfanovcv.par('ds',rsf.doc.rsfpar('float','','','''s step size '''))
sfanovcv.par('s0',rsf.doc.rsfpar('float','','',''''''))
sfanovcv.par('smax',rsf.doc.rsfpar('float','','',''''''))
sfanovcv.par('epsr',rsf.doc.rsfpar('float','0.001','','''damper for root '''))
sfanovcv.par('s0',rsf.doc.rsfpar('float','','','''start '''))
sfanovcv.par('velocity',rsf.doc.rsfpar('string ',desc='''velocity file (auxiliary input file name)'''))
sfanovcv.par('kappa1',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfanovcv.par('kappa2',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfanovcv.par('kappa3',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfanovcv.par('rootin',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfanovcv.version('2.1-git')
sfanovcv.synopsis('''sfanovcv < in.rsf > out.rsf velocity=vel.rsf kappa1=kappa1file.rsf kappa2=kappa2file.rsf kappa3=kappa3file.rsf rootin=rootin.rsf eps=0.1 clip=0.5 windowtime=t0 + (nt-1.0)*dt nv=1 lagrange=n plus=y debug=y isotr=n testwarp=n full=n v0= v0= ns=1 ds= s0= smax= epsr=0.001 s0=''','''
Axis order: t, p, x
''')
rsf.doc.progs['sfanovcv']=sfanovcv

sfmig2s = rsf.doc.rsfprog('sfmig2s','user/dmerzlikin/Mmig2s.c','''2-D Prestack Kirchhoff time migration with antialiasing.''')
sfmig2s.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfmig2s.par('gather',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfmig2s.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfmig2s.par('adj',rsf.doc.rsfpar('bool','y','','''adjoint flag (y for migration, n for modeling) '''))
sfmig2s.par('normalize',rsf.doc.rsfpar('bool','y','','''normalize for the fold '''))
sfmig2s.par('nh',rsf.doc.rsfpar('int','','','''number of offsets (for modeling) '''))
sfmig2s.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sfmig2s.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sfmig2s.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sfmig2s.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sfmig2s.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sfmig2s.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sfmig2s.par('s',rsf.doc.rsfpar('float','1.','',''''''))
sfmig2s.par('dh',rsf.doc.rsfpar('float','','','''offset sampling (for modeling) '''))
sfmig2s.par('h0',rsf.doc.rsfpar('float','','','''first offset (for modeling) '''))
sfmig2s.par('gather',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfmig2s.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sfmig2s.version('2.1-git')
sfmig2s.synopsis('''sfmig2s < inp.rsf vel=vel.rsf > out.rsf gather=gather.rsf offset=offset.rsf adj=y normalize=y nh= antialias=1.0 apt=nx angle=90.0 half=y verb=y rho=1.-1./nt s=1. dh= h0=''','''Shifted hyperbola travel-time approximation.
Tested for zero-offset only 
The axes in the input are {time,midpoint,offset}
The axes in the offset are {1,midpoint,offset}
The axes in the output are {time,midpoint}
The axes in the "image gather" are {time,midpoint,offset}
''')
rsf.doc.progs['sfmig2s']=sfmig2s

sfmig2semb = rsf.doc.rsfprog('sfmig2semb','user/dmerzlikin/Mmig2semb.c','''2-D Prestack Kirchhoff time migration with antialiasing. ''')
sfmig2semb.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfmig2semb.par('semblance',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfmig2semb.par('gather',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfmig2semb.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfmig2semb.par('adj',rsf.doc.rsfpar('bool','y','','''adjoint flag (y for migration, n for modeling) '''))
sfmig2semb.par('normalize',rsf.doc.rsfpar('bool','y','','''normalize for the fold '''))
sfmig2semb.par('nh',rsf.doc.rsfpar('int','','','''number of offsets (for modeling) '''))
sfmig2semb.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sfmig2semb.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sfmig2semb.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sfmig2semb.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sfmig2semb.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sfmig2semb.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sfmig2semb.par('dh',rsf.doc.rsfpar('float','','','''offset sampling (for modeling) '''))
sfmig2semb.par('h0',rsf.doc.rsfpar('float','','','''first offset (for modeling) '''))
sfmig2semb.par('gather',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfmig2semb.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sfmig2semb.version('2.1-git')
sfmig2semb.synopsis('''sfmig2semb < inp.rsf vel=vel.rsf > out.rsf semblance=semblance.rsf gather=gather.rsf offset=offset.rsf adj=y normalize=y nh= antialias=1.0 apt=nx angle=90.0 half=y verb=y rho=1.-1./nt dh= h0=''','''The axes in the input are {time,midpoint,offset}
The axes in the offset are {1,midpoint,offset}
The axes in the output are {time,midpoint}
The axes in the "image gather" are {time,midpoint,offset}
''')
rsf.doc.progs['sfmig2semb']=sfmig2semb

sflinpipwd2d = rsf.doc.rsfprog('sflinpipwd2d','user/dmerzlikin/Mlinpipwd2d.c','''pi operator building wrapping test function flat gaussian weighting smoothing after pi''')
sflinpipwd2d.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinpipwd2d.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinpipwd2d.par('adj',rsf.doc.rsfpar('bool','n','','''adjoint flag '''))
sflinpipwd2d.par('sm',rsf.doc.rsfpar('bool','y','','''if perform derivative filtering = PWD '''))
sflinpipwd2d.par('domod',rsf.doc.rsfpar('bool','y','','''if perform modeling via Kirchhoff '''))
sflinpipwd2d.par('doomp',rsf.doc.rsfpar('bool','y','','''OMP is forced currently '''))
sflinpipwd2d.par('dopi',rsf.doc.rsfpar('bool','y','','''if do pi '''))
sflinpipwd2d.par('ps',rsf.doc.rsfpar('bool','y','','''spherical divergence '''))
sflinpipwd2d.par('dd',rsf.doc.rsfpar('bool','y','','''differentiation in the data domain '''))
sflinpipwd2d.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sflinpipwd2d.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sflinpipwd2d.par('hd',rsf.doc.rsfpar('bool','y','','''half differentiation '''))
sflinpipwd2d.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sflinpipwd2d.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sflinpipwd2d.par('v_1',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2d.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2d.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2d.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2d.par('passthr',rsf.doc.rsfpar('float','0.001','','''threshold for tail elimination '''))
sflinpipwd2d.par('eps',rsf.doc.rsfpar('float','0.001','','''damper for pi '''))
sflinpipwd2d.par('epst2',rsf.doc.rsfpar('float','0.001','','''damper for t2warp '''))
sflinpipwd2d.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sflinpipwd2d.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sflinpipwd2d.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing '''))
sflinpipwd2d.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sflinpipwd2d.version('2.1-git')
sflinpipwd2d.synopsis('''sflinpipwd2d < inp.rsf > out.rsf vel=vel.rsf dip=dip.rsf adj=n sm=y domod=y doomp=y dopi=y ps=y dd=y apt=nx angle=90.0 hd=y verb=y rho=1.-1./nt v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt order=1 nj1=1 antialias=''','''''')
rsf.doc.progs['sflinpipwd2d']=sflinpipwd2d

sflinpipwd2dca = rsf.doc.rsfprog('sflinpipwd2dca','user/dmerzlikin/Mlinpipwd2dca.c','''pi operator building wrapping test function flat gaussian weighting smoothing after pi''')
sflinpipwd2dca.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinpipwd2dca.par('dip1',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinpipwd2dca.par('dip2',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinpipwd2dca.par('dip3',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinpipwd2dca.par('outpwd',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sflinpipwd2dca.par('outdip',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sflinpipwd2dca.par('gather',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sflinpipwd2dca.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinpipwd2dca.par('adj',rsf.doc.rsfpar('bool','n','','''if perform derivative filtering = PWD '''))
sflinpipwd2dca.par('sm',rsf.doc.rsfpar('bool','y','','''if perform modelling via Kirchhoff '''))
sflinpipwd2dca.par('domod',rsf.doc.rsfpar('bool','y','','''debug flag '''))
sflinpipwd2dca.par('debug',rsf.doc.rsfpar('bool','','',''''''))
sflinpipwd2dca.par('normalize',rsf.doc.rsfpar('bool','y','','''normalize for the fold '''))
sflinpipwd2dca.par('nh',rsf.doc.rsfpar('int','','','''number of offsets (for modeling) '''))
sflinpipwd2dca.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sflinpipwd2dca.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sflinpipwd2dca.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sflinpipwd2dca.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sflinpipwd2dca.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sflinpipwd2dca.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sflinpipwd2dca.par('dh',rsf.doc.rsfpar('float','','','''offset sampling (for modeling) '''))
sflinpipwd2dca.par('h0',rsf.doc.rsfpar('float','','','''first offset (for modeling) '''))
sflinpipwd2dca.par('v_1',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2dca.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2dca.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2dca.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sflinpipwd2dca.par('passthr',rsf.doc.rsfpar('float','0.001','',''''''))
sflinpipwd2dca.par('eps',rsf.doc.rsfpar('float','0.001','',''''''))
sflinpipwd2dca.par('epst2',rsf.doc.rsfpar('float','0.001','',''''''))
sflinpipwd2dca.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sflinpipwd2dca.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sflinpipwd2dca.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing '''))
sflinpipwd2dca.par('gather',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sflinpipwd2dca.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sflinpipwd2dca.version('2.1-git')
sflinpipwd2dca.synopsis('''sflinpipwd2dca < inp.rsf > out.rsf vel=vel.rsf dip1=dip1.rsf dip2=dip2.rsf dip3=dip3.rsf outpwd=outpwdcheck.rsf outdip=outdipcheck.rsf gather=gather.rsf offset=offset.rsf adj=n sm=y domod=y debug= normalize=y nh= antialias=1.0 apt=nx angle=90.0 half=y verb=y rho=1.-1./nt dh= h0= v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt order=1 nj1=1''','''''')
rsf.doc.progs['sflinpipwd2dca']=sflinpipwd2dca

sfmig2pwd = rsf.doc.rsfprog('sfmig2pwd','user/dmerzlikin/Mmig2pwd.c','''combination of mig2 Kirchhoff migration nad PWD filtering''')
sfmig2pwd.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfmig2pwd.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfmig2pwd.par('outpwd',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfmig2pwd.par('outdip',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfmig2pwd.par('gather',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfmig2pwd.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfmig2pwd.par('adj',rsf.doc.rsfpar('bool','n','','''if perform derivative filtering = PWD '''))
sfmig2pwd.par('sm',rsf.doc.rsfpar('bool','y','','''if perform modelling via Kirchhoff '''))
sfmig2pwd.par('domod',rsf.doc.rsfpar('bool','y','','''debug flag '''))
sfmig2pwd.par('debug',rsf.doc.rsfpar('bool','','',''''''))
sfmig2pwd.par('normalize',rsf.doc.rsfpar('bool','y','','''normalize for the fold '''))
sfmig2pwd.par('nh',rsf.doc.rsfpar('int','','','''number of offsets (for modeling) '''))
sfmig2pwd.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sfmig2pwd.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sfmig2pwd.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sfmig2pwd.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sfmig2pwd.par('verb',rsf.doc.rsfpar('bool','y','','''verbosity flag '''))
sfmig2pwd.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sfmig2pwd.par('dh',rsf.doc.rsfpar('float','','','''offset sampling (for modeling) '''))
sfmig2pwd.par('h0',rsf.doc.rsfpar('float','','','''first offset (for modeling) '''))
sfmig2pwd.par('v_1',rsf.doc.rsfpar('float','','',''''''))
sfmig2pwd.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sfmig2pwd.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sfmig2pwd.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sfmig2pwd.par('passthr',rsf.doc.rsfpar('float','0.001','',''''''))
sfmig2pwd.par('eps',rsf.doc.rsfpar('float','0.001','',''''''))
sfmig2pwd.par('epst2',rsf.doc.rsfpar('float','0.001','',''''''))
sfmig2pwd.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sfmig2pwd.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sfmig2pwd.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing '''))
sfmig2pwd.par('gather',rsf.doc.rsfpar('string ',desc='''auxiliary output file name'''))
sfmig2pwd.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sfmig2pwd.version('2.1-git')
sfmig2pwd.synopsis('''sfmig2pwd < inp.rsf > out.rsf vel=vel.rsf dip=dip.rsf outpwd=outpwdcheck.rsf outdip=outdipcheck.rsf gather=gather.rsf offset=offset.rsf adj=n sm=y domod=y debug= normalize=y nh= antialias=1.0 apt=nx angle=90.0 half=y verb=y rho=1.-1./nt dh= h0= v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt order=1 nj1=1''','''''')
rsf.doc.progs['sfmig2pwd']=sfmig2pwd

sfpwdtensor = rsf.doc.rsfprog('sfpwdtensor','user/dmerzlikin/Mpwdtensor.c','''structure tensor estimation based on plane wave destruction. ''')
sfpwdtensor.par('in2',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpwdtensor.par('in3',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpwdtensor.par('out2',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensor.par('uver',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensor.par('uhor',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensor.par('vver',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensor.par('vhor',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensor.par('eps',rsf.doc.rsfpar('float','0.00001','',''''''))
sfpwdtensor.par('normalize',rsf.doc.rsfpar('bool','n','',''''''))
sfpwdtensor.version('2.1-git')
sfpwdtensor.synopsis('''sfpwdtensor < in.rsf in2=in2.rsf in3=in3.rsf > out.rsf out2=out2.rsf uver=uver.rsf uhor=uhor.rsf vver=vver.rsf vhor=vhor.rsf eps=0.00001 normalize=n''','''''')
rsf.doc.progs['sfpwdtensor']=sfpwdtensor

sfpwdtensorh = rsf.doc.rsfprog('sfpwdtensorh','user/dmerzlikin/Mpwdtensorh.c','''structure tensor estimation based on plane wave destruction. ''')
sfpwdtensorh.par('in2',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpwdtensorh.par('in3',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpwdtensorh.par('out2',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensorh.par('ux',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensorh.par('uy',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensorh.par('vx',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensorh.par('vy',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfpwdtensorh.par('eps',rsf.doc.rsfpar('float','0.00001','',''''''))
sfpwdtensorh.par('normalize',rsf.doc.rsfpar('bool','n','',''''''))
sfpwdtensorh.version('2.1-git')
sfpwdtensorh.synopsis('''sfpwdtensorh < in.rsf in2=in2.rsf in3=in3.rsf > out.rsf out2=out2.rsf ux=uxf.rsf uy=uyf.rsf vx=vxf.rsf vy=vyf.rsf eps=0.00001 normalize=n''','''''')
rsf.doc.progs['sfpwdtensorh']=sfpwdtensorh

sflsmig3 = rsf.doc.rsfprog('sflsmig3','user/dmerzlikin/Mlsmig3.c','''Least-Squares 3D Path-Summation Integral, Azimuthal Plane-Wave Destruction and Kirchhoff Modeling/Migration Chain of Operators''')
sflsmig3.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflsmig3.par('az',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflsmig3.par('vx',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflsmig3.par('vy',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflsmig3.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflsmig3.par('snapsf',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sflsmig3.par('adj',rsf.doc.rsfpar('bool','n','','''Adjoint flag '''))
sflsmig3.par('v_1',rsf.doc.rsfpar('float','','','''Path-integral range '''))
sflsmig3.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sflsmig3.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sflsmig3.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sflsmig3.par('passthr',rsf.doc.rsfpar('float','0.001','','''Threshold for tail elimination '''))
sflsmig3.par('eps',rsf.doc.rsfpar('float','0.001','','''Damper for pi '''))
sflsmig3.par('epst2',rsf.doc.rsfpar('float','0.001','','''Damper for t2warp '''))
sflsmig3.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sflsmig3.par('vel',rsf.doc.rsfpar('float','','','''migration velocity for Kirchhoff '''))
sflsmig3.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sflsmig3.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sflsmig3.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sflsmig3.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sflsmig3.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing iline '''))
sflsmig3.par('nj2',rsf.doc.rsfpar('int','1','','''antialiasing xline '''))
sflsmig3.par('sm',rsf.doc.rsfpar('bool','y','','''if perform AzPWD filtering '''))
sflsmig3.par('domod',rsf.doc.rsfpar('bool','y','','''if perform Kirchhoff modeling/migration '''))
sflsmig3.par('dopi',rsf.doc.rsfpar('bool','y','','''if perform PI filtering '''))
sflsmig3.par('doanisodiff',rsf.doc.rsfpar('bool','y','','''if perform anisotropic diffusion regularization '''))
sflsmig3.par('dothr',rsf.doc.rsfpar('bool','y','','''if perform sparse regularization '''))
sflsmig3.par('doomp',rsf.doc.rsfpar('bool','n','','''OpenMP '''))
sflsmig3.par('snaps',rsf.doc.rsfpar('bool','n','','''if do snapshots of outer iterations '''))
sflsmig3.par('dsnaps',rsf.doc.rsfpar('int','1','','''snapshots interval '''))
sflsmig3.par('initer',rsf.doc.rsfpar('int','2','','''inner iterations '''))
sflsmig3.par('oniter',rsf.doc.rsfpar('int','1','','''outer iterations '''))
sflsmig3.par('niter',rsf.doc.rsfpar('int','10','','''Anisotropic diffusion: number of conjugate-gradient iterations '''))
sflsmig3.par('repeat',rsf.doc.rsfpar('int','1','','''Anisotropic diffusion: number of smoothing iterations '''))
sflsmig3.par('anisoeps',rsf.doc.rsfpar('float','1.','','''Anisotropic diffusion: regularization parameter '''))
sflsmig3.par('thr',rsf.doc.rsfpar('float','','','''Thresholding level '''))
sflsmig3.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sflsmig3.par('mode',rsf.doc.rsfpar('string ',desc=''''soft', 'hard', 'nng' (default: soft)'''))
sflsmig3.version('2.1-git')
sflsmig3.synopsis('''sflsmig3 < inp.rsf > out.rsf dip=dip.rsf az=azin.rsf vx=fvx.rsf vy=fvy.rsf vel=velFile.rsf snapsf=snapsf.rsf adj=n v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt vel= rho=1.-1./nt apt=nx angle=90.0 order=1 nj1=1 nj2=1 sm=y domod=y dopi=y doanisodiff=y dothr=y doomp=n snaps=n dsnaps=1 initer=2 oniter=1 niter=10 repeat=1 anisoeps=1. thr= antialias= mode=''','''''')
rsf.doc.progs['sflsmig3']=sflsmig3

sflinpi = rsf.doc.rsfprog('sflinpi','user/dmerzlikin/Mlinpi.c','''3D Path-Summation Integral Operator as a Linear Filter''')
sflinpi.par('adj',rsf.doc.rsfpar('bool','n','','''adjoint flag '''))
sflinpi.par('v_1',rsf.doc.rsfpar('float','','','''path-integral range '''))
sflinpi.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sflinpi.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sflinpi.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sflinpi.par('passthr',rsf.doc.rsfpar('float','0.001','',''''''))
sflinpi.par('eps',rsf.doc.rsfpar('float','0.001','',''''''))
sflinpi.par('epst2',rsf.doc.rsfpar('float','0.001','',''''''))
sflinpi.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sflinpi.version('2.1-git')
sflinpi.synopsis('''sflinpi < inp.rsf > out.rsf adj=n v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt''','''''')
rsf.doc.progs['sflinpi']=sflinpi

sfpipwdmig2 = rsf.doc.rsfprog('sfpipwdmig2','user/dmerzlikin/Mpipwdmig2.c','''Chain of Path Integral, Plane-Wave Destruction and Kirchhoff migration (based on sfmig2)''')
sfpipwdmig2.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpipwdmig2.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpipwdmig2.par('adj',rsf.doc.rsfpar('bool','n','','''adjoint flag '''))
sfpipwdmig2.par('sm',rsf.doc.rsfpar('bool','y','','''if perform Plane-Wave destruction (if disabled -> chain = P L) '''))
sfpipwdmig2.par('domod',rsf.doc.rsfpar('bool','y','','''if perform modeling via Kirchhoff (if disabled -> chain = P PWD) '''))
sfpipwdmig2.par('pi',rsf.doc.rsfpar('bool','y','','''if perform Path-Integral filtering (if disabled -> chain = PWD L) '''))
sfpipwdmig2.par('verb',rsf.doc.rsfpar('bool','n','','''verbose flag '''))
sfpipwdmig2.par('doomp',rsf.doc.rsfpar('bool','y','','''OMP flag - currently hard-coded to y '''))
sfpipwdmig2.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sfpipwdmig2.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sfpipwdmig2.par('hd',rsf.doc.rsfpar('bool','y','','''half derivative '''))
sfpipwdmig2.par('ps',rsf.doc.rsfpar('bool','y','','''amplitude correction '''))
sfpipwdmig2.par('dd',rsf.doc.rsfpar('bool','y','','''differentiation in the data domain '''))
sfpipwdmig2.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sfpipwdmig2.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''leaky integration constant '''))
sfpipwdmig2.par('v_1',rsf.doc.rsfpar('float','','','''no pass velocity '''))
sfpipwdmig2.par('v_2',rsf.doc.rsfpar('float','','','''first pass velocity '''))
sfpipwdmig2.par('v_3',rsf.doc.rsfpar('float','','','''second pass velocity '''))
sfpipwdmig2.par('v_4',rsf.doc.rsfpar('float','','','''no pass velocity '''))
sfpipwdmig2.par('passthr',rsf.doc.rsfpar('float','0.001','','''threshold for tail elimination '''))
sfpipwdmig2.par('eps',rsf.doc.rsfpar('float','0.001','','''damper for pi '''))
sfpipwdmig2.par('epst2',rsf.doc.rsfpar('float','0.001','','''damper for t2warp '''))
sfpipwdmig2.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sfpipwdmig2.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sfpipwdmig2.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing '''))
sfpipwdmig2.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sfpipwdmig2.version('2.1-git')
sfpipwdmig2.synopsis('''sfpipwdmig2 < inp.rsf > out.rsf vel=fvel.rsf dip=dip.rsf adj=n sm=y domod=y pi=y verb=n doomp=y apt=nx angle=90.0 hd=y ps=y dd=y half=y rho=1.-1./nt v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt order=1 nj1=1 antialias=''','''
works only for zero offset

make sure nh = 1 dh = 1.0 h0 = 0.0 offset file is not used

there are flags to disable PWD (Plane-Wave Destruction), P (Path-Integral Filter) and L (Kirchhoff modelling/migration)

no regularization

can be expressed for forward as: data = P PWD L ( reflections + diffractions ) or as a matrix

.                     | reflections  |
| P PWD L   P PWD L | |              | = | data |           
.                     | diffractions |           

can be expressed for adjoint as:

adjoint reflections = L^T PWD^T P^T data

adjoint diffractions = L^T PWD^T P^T data or as a matrix

| reflections  |   | L^T PWD^T P^T |
|              | = |               | | data |
| diffractions |   | L^T PWD^T P^T |

''')
rsf.doc.progs['sfpipwdmig2']=sfpipwdmig2

sflinmig3 = rsf.doc.rsfprog('sflinmig3','user/dmerzlikin/Mlinmig3.c','''3-D Kirchhoff time migration with antialiasing with adjoint flag. ''')
sflinmig3.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinmig3.par('n1',rsf.doc.rsfpar('int','','',''''''))
sflinmig3.par('adj',rsf.doc.rsfpar('bool','y','','''adjoint flag '''))
sflinmig3.par('doomp',rsf.doc.rsfpar('bool','n','','''perform OpenMP optimization '''))
sflinmig3.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sflinmig3.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sflinmig3.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sflinmig3.par('vel',rsf.doc.rsfpar('float','','','''migration velocity '''))
sflinmig3.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sflinmig3.version('2.1-git')
sflinmig3.synopsis('''sflinmig3 < in.rsf > mig.rsf vel=velFile.rsf n1= adj=y doomp=n rho=1.-1./nt apt=nx angle=90.0 vel= antialias=''','''''')
rsf.doc.progs['sflinmig3']=sflinmig3

sflspiazpwdmig3 = rsf.doc.rsfprog('sflspiazpwdmig3','user/dmerzlikin/Mlspiazpwdmig3.c','''Least-Squares 3D Path-Summation Integral, Azimuthal Plane-Wave Destruction and Kirchhoff Modeling/Migration Chain of Operators''')
sflspiazpwdmig3.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig3.par('az',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig3.par('vx',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig3.par('vy',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig3.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig3.par('snapsf',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sflspiazpwdmig3.par('adj',rsf.doc.rsfpar('bool','n','','''Adjoint flag '''))
sflspiazpwdmig3.par('v_1',rsf.doc.rsfpar('float','','','''Path-integral range '''))
sflspiazpwdmig3.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sflspiazpwdmig3.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sflspiazpwdmig3.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sflspiazpwdmig3.par('passthr',rsf.doc.rsfpar('float','0.001','','''Threshold for tail elimination '''))
sflspiazpwdmig3.par('eps',rsf.doc.rsfpar('float','0.001','','''Damper for pi '''))
sflspiazpwdmig3.par('epst2',rsf.doc.rsfpar('float','0.001','','''Damper for t2warp '''))
sflspiazpwdmig3.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sflspiazpwdmig3.par('vel',rsf.doc.rsfpar('float','','','''migration velocity for Kirchhoff '''))
sflspiazpwdmig3.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sflspiazpwdmig3.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sflspiazpwdmig3.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sflspiazpwdmig3.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sflspiazpwdmig3.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing iline '''))
sflspiazpwdmig3.par('nj2',rsf.doc.rsfpar('int','1','','''antialiasing xline '''))
sflspiazpwdmig3.par('sm',rsf.doc.rsfpar('bool','y','','''if perform AzPWD filtering '''))
sflspiazpwdmig3.par('domod',rsf.doc.rsfpar('bool','y','','''if perform Kirchhoff modeling/migration '''))
sflspiazpwdmig3.par('dopi',rsf.doc.rsfpar('bool','y','','''if perform PI filtering '''))
sflspiazpwdmig3.par('doanisodiff',rsf.doc.rsfpar('bool','y','','''if perform anisotropic diffusion regularization '''))
sflspiazpwdmig3.par('dothr',rsf.doc.rsfpar('bool','y','','''if perform sparse regularization '''))
sflspiazpwdmig3.par('doomp',rsf.doc.rsfpar('bool','n','','''OpenMP '''))
sflspiazpwdmig3.par('snaps',rsf.doc.rsfpar('bool','n','','''if do snapshots of outer iterations '''))
sflspiazpwdmig3.par('dsnaps',rsf.doc.rsfpar('int','1','','''snapshots interval '''))
sflspiazpwdmig3.par('initer',rsf.doc.rsfpar('int','2','','''inner iterations '''))
sflspiazpwdmig3.par('oniter',rsf.doc.rsfpar('int','1','','''outer iterations '''))
sflspiazpwdmig3.par('niter',rsf.doc.rsfpar('int','10','','''Anisotropic diffusion: number of conjugate-gradient iterations '''))
sflspiazpwdmig3.par('repeat',rsf.doc.rsfpar('int','1','','''Anisotropic diffusion: number of smoothing iterations '''))
sflspiazpwdmig3.par('anisoeps',rsf.doc.rsfpar('float','1.','','''Anisotropic diffusion: regularization parameter '''))
sflspiazpwdmig3.par('thr',rsf.doc.rsfpar('float','','','''Thresholding level '''))
sflspiazpwdmig3.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sflspiazpwdmig3.par('mode',rsf.doc.rsfpar('string ',desc=''''soft', 'hard', 'nng' (default: soft)'''))
sflspiazpwdmig3.version('2.1-git')
sflspiazpwdmig3.synopsis('''sflspiazpwdmig3 < inp.rsf > out.rsf dip=dip.rsf az=azin.rsf vx=fvx.rsf vy=fvy.rsf vel=velFile.rsf snapsf=snapsf.rsf adj=n v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt vel= rho=1.-1./nt apt=nx angle=90.0 order=1 nj1=1 nj2=1 sm=y domod=y dopi=y doanisodiff=y dothr=y doomp=n snaps=n dsnaps=1 initer=2 oniter=1 niter=10 repeat=1 anisoeps=1. thr= antialias= mode=''','''''')
rsf.doc.progs['sflspiazpwdmig3']=sflspiazpwdmig3

sflspiazpwdmig32 = rsf.doc.rsfprog('sflspiazpwdmig32','user/dmerzlikin/Mlspiazpwdmig32.c','''Least-Squares 3D Path-Summation Integral, Azimuthal Plane-Wave Destruction and Kirchhoff Modeling/Migration Chain of Operators. Shaping is pwddiffuse''')
sflspiazpwdmig32.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig32.par('dipim',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig32.par('az',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig32.par('vx',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig32.par('vy',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig32.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflspiazpwdmig32.par('snapsf',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sflspiazpwdmig32.par('adj',rsf.doc.rsfpar('bool','n','','''Adjoint flag '''))
sflspiazpwdmig32.par('v_1',rsf.doc.rsfpar('float','','','''Path-integral range '''))
sflspiazpwdmig32.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sflspiazpwdmig32.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sflspiazpwdmig32.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sflspiazpwdmig32.par('passthr',rsf.doc.rsfpar('float','0.001','','''Threshold for tail elimination '''))
sflspiazpwdmig32.par('eps',rsf.doc.rsfpar('float','0.001','','''Damper for pi '''))
sflspiazpwdmig32.par('epst2',rsf.doc.rsfpar('float','0.001','','''Damper for t2warp '''))
sflspiazpwdmig32.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sflspiazpwdmig32.par('vel',rsf.doc.rsfpar('float','','','''migration velocity for Kirchhoff '''))
sflspiazpwdmig32.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sflspiazpwdmig32.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sflspiazpwdmig32.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sflspiazpwdmig32.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sflspiazpwdmig32.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing iline '''))
sflspiazpwdmig32.par('nj2',rsf.doc.rsfpar('int','1','','''antialiasing xline '''))
sflspiazpwdmig32.par('sm',rsf.doc.rsfpar('bool','y','','''if perform AzPWD filtering '''))
sflspiazpwdmig32.par('domod',rsf.doc.rsfpar('bool','y','','''if perform Kirchhoff modeling/migration '''))
sflspiazpwdmig32.par('dopi',rsf.doc.rsfpar('bool','y','','''if perform PI filtering '''))
sflspiazpwdmig32.par('doanisodiff',rsf.doc.rsfpar('bool','y','','''if perform anisotropic diffusion regularization '''))
sflspiazpwdmig32.par('dothr',rsf.doc.rsfpar('bool','y','','''if perform sparse regularization '''))
sflspiazpwdmig32.par('doomp',rsf.doc.rsfpar('bool','n','','''OpenMP '''))
sflspiazpwdmig32.par('snaps',rsf.doc.rsfpar('bool','n','','''if do snapshots of outer iterations '''))
sflspiazpwdmig32.par('dsnaps',rsf.doc.rsfpar('int','1','','''snapshots interval '''))
sflspiazpwdmig32.par('initer',rsf.doc.rsfpar('int','2','','''inner iterations '''))
sflspiazpwdmig32.par('oniter',rsf.doc.rsfpar('int','1','','''outer iterations '''))
sflspiazpwdmig32.par('niter',rsf.doc.rsfpar('int','10','','''Anisotropic diffusion: number of conjugate-gradient iterations '''))
sflspiazpwdmig32.par('repeat',rsf.doc.rsfpar('int','1','','''Anisotropic diffusion: number of smoothing iterations '''))
sflspiazpwdmig32.par('anisoeps',rsf.doc.rsfpar('float','1.','','''Anisotropic diffusion: regularization parameter '''))
sflspiazpwdmig32.par('thr',rsf.doc.rsfpar('float','','','''Thresholding level '''))
sflspiazpwdmig32.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sflspiazpwdmig32.par('mode',rsf.doc.rsfpar('string ',desc=''''soft', 'hard', 'nng' (default: soft)'''))
sflspiazpwdmig32.version('2.1-git')
sflspiazpwdmig32.synopsis('''sflspiazpwdmig32 < inp.rsf > out.rsf dip=dip.rsf dipim=dipImage.rsf az=azin.rsf vx=fvx.rsf vy=fvy.rsf vel=velFile.rsf snapsf=snapsf.rsf adj=n v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt vel= rho=1.-1./nt apt=nx angle=90.0 order=1 nj1=1 nj2=1 sm=y domod=y dopi=y doanisodiff=y dothr=y doomp=n snaps=n dsnaps=1 initer=2 oniter=1 niter=10 repeat=1 anisoeps=1. thr= antialias= mode=''','''''')
rsf.doc.progs['sflspiazpwdmig32']=sflspiazpwdmig32

sfpiazpwdmig3 = rsf.doc.rsfprog('sfpiazpwdmig3','user/dmerzlikin/Mpiazpwdmig3.c','''Least-Squares 3D Path-Summation Integral, Azimuthal Plane-Wave Destruction and Kirchhoff Modeling/Migration Chain of Operators''')
sfpiazpwdmig3.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpiazpwdmig3.par('az',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpiazpwdmig3.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpiazpwdmig3.par('adj',rsf.doc.rsfpar('bool','n','','''Adjoint flag '''))
sfpiazpwdmig3.par('v_1',rsf.doc.rsfpar('float','','','''Path-integral range '''))
sfpiazpwdmig3.par('v_2',rsf.doc.rsfpar('float','','',''''''))
sfpiazpwdmig3.par('v_3',rsf.doc.rsfpar('float','','',''''''))
sfpiazpwdmig3.par('v_4',rsf.doc.rsfpar('float','','',''''''))
sfpiazpwdmig3.par('passthr',rsf.doc.rsfpar('float','0.001','','''Threshold for tail elimination '''))
sfpiazpwdmig3.par('eps',rsf.doc.rsfpar('float','0.001','','''Damper for pi '''))
sfpiazpwdmig3.par('epst2',rsf.doc.rsfpar('float','0.001','','''Damper for t2warp '''))
sfpiazpwdmig3.par('pad',rsf.doc.rsfpar('int','nt','','''output time samples '''))
sfpiazpwdmig3.par('vel',rsf.doc.rsfpar('float','','','''migration velocity for Kirchhoff '''))
sfpiazpwdmig3.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sfpiazpwdmig3.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sfpiazpwdmig3.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sfpiazpwdmig3.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sfpiazpwdmig3.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing iline '''))
sfpiazpwdmig3.par('nj2',rsf.doc.rsfpar('int','1','','''antialiasing xline '''))
sfpiazpwdmig3.par('sm',rsf.doc.rsfpar('bool','y','','''if perform AzPWD filtering '''))
sfpiazpwdmig3.par('domod',rsf.doc.rsfpar('bool','y','','''if perform Kirchhoff modeling/migration '''))
sfpiazpwdmig3.par('dopi',rsf.doc.rsfpar('bool','y','','''if perform PI filtering '''))
sfpiazpwdmig3.par('doomp',rsf.doc.rsfpar('bool','n','','''OpenMP '''))
sfpiazpwdmig3.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sfpiazpwdmig3.version('2.1-git')
sfpiazpwdmig3.synopsis('''sfpiazpwdmig3 < inp.rsf > out.rsf dip=dip.rsf az=azin.rsf vel=velFile.rsf adj=n v_1= v_2= v_3= v_4= passthr=0.001 eps=0.001 epst2=0.001 pad=nt vel= rho=1.-1./nt apt=nx angle=90.0 order=1 nj1=1 nj2=1 sm=y domod=y dopi=y doomp=n antialias=''','''''')
rsf.doc.progs['sfpiazpwdmig3']=sfpiazpwdmig3

sfazpwd = rsf.doc.rsfprog('sfazpwd','user/dmerzlikin/Mazpwd.c','''Azimuthal Plane-Wave Destruction ''')
sfazpwd.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfazpwd.par('az',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfazpwd.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sfazpwd.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing iline '''))
sfazpwd.par('nj2',rsf.doc.rsfpar('int','1','','''antialiasing xline '''))
sfazpwd.par('sm',rsf.doc.rsfpar('bool','y','','''if perform AzPWD filtering '''))
sfazpwd.par('adj',rsf.doc.rsfpar('bool','n','','''adjoint flag '''))
sfazpwd.version('2.1-git')
sfazpwd.synopsis('''sfazpwd < in.rsf dip=dip.rsf az=azin.rsf > out.rsf order=1 nj1=1 nj2=1 sm=y adj=n''','''''')
rsf.doc.progs['sfazpwd']=sfazpwd

sfanisodiffuse = rsf.doc.rsfprog('sfanisodiffuse','user/dmerzlikin/Manisodiffuse.c','''Anisotropic diffusion by regularized inversion. Applied in 3D in a slice by slice fashion: set of''')
sfanisodiffuse.par('vx',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfanisodiffuse.par('vy',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfanisodiffuse.par('niter',rsf.doc.rsfpar('int','10','','''number of conjugate-gradient iterations '''))
sfanisodiffuse.par('repeat',rsf.doc.rsfpar('int','1','','''number of smoothing iterations '''))
sfanisodiffuse.par('eps',rsf.doc.rsfpar('float','1.','','''regularization parameter '''))
sfanisodiffuse.version('2.1-git')
sfanisodiffuse.synopsis('''sfanisodiffuse < in.rsf > out.rsf vx=fvx.rsf vy=fvy.rsf niter=10 repeat=1 eps=1.''','''2D diffusions for a fixed time sample. ''')
rsf.doc.progs['sfanisodiffuse']=sfanisodiffuse

sfazspr = rsf.doc.rsfprog('sfazspr','user/dmerzlikin/Mazspr.c','''Combining Sprays: Simply Input Sprays in In-line And Cross-line ''')
sfazspr.par('spry',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfazspr.par('az',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfazspr.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sfazspr.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing iline '''))
sfazspr.par('nj2',rsf.doc.rsfpar('int','1','','''antialiasing xline '''))
sfazspr.par('sm',rsf.doc.rsfpar('bool','y','','''if perform AzPWD filtering '''))
sfazspr.par('adj',rsf.doc.rsfpar('bool','n','','''adjoint flag '''))
sfazspr.version('2.1-git')
sfazspr.synopsis('''sfazspr < in.rsf spry=in2.rsf az=azin.rsf > out.rsf order=1 nj1=1 nj2=1 sm=y adj=n''','''''')
rsf.doc.progs['sfazspr']=sfazspr

sflinmig2 = rsf.doc.rsfprog('sflinmig2','user/dmerzlikin/Mlinmig2.c','''2-D Kirchhoff time migration with antialiasing with adjoint flag. ''')
sflinmig2.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflinmig2.par('n1',rsf.doc.rsfpar('int','','',''''''))
sflinmig2.par('adj',rsf.doc.rsfpar('bool','y','','''adjoint flag '''))
sflinmig2.par('ps',rsf.doc.rsfpar('bool','y','','''spherical divergence '''))
sflinmig2.par('doomp',rsf.doc.rsfpar('bool','y','','''perform OpenMP optimization '''))
sflinmig2.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sflinmig2.par('hd',rsf.doc.rsfpar('bool','y','','''half derivative '''))
sflinmig2.par('apt',rsf.doc.rsfpar('int','nx','','''integral aperture '''))
sflinmig2.par('angle',rsf.doc.rsfpar('float','90.0','','''angle aperture '''))
sflinmig2.par('dd',rsf.doc.rsfpar('bool','y','','''differentiation in the data domain '''))
sflinmig2.par('antialias',rsf.doc.rsfpar('string ',desc='''antialiasing type [triangle,flat,steep,none] '''))
sflinmig2.version('2.1-git')
sflinmig2.synopsis('''sflinmig2 < in.rsf > mig.rsf vel=fvel.rsf n1= adj=y ps=y doomp=y rho=1.-1./nt hd=y apt=nx angle=90.0 dd=y antialias=''','''''')
rsf.doc.progs['sflinmig2']=sflinmig2

sfpwddiffuse = rsf.doc.rsfprog('sfpwddiffuse','user/dmerzlikin/Mpwddiffuse.c','''Anisotropic diffusion by regularized inversion. Instead of a gradient PWDs in inline and crossline directions are used. 3D. ''')
sfpwddiffuse.par('dip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpwddiffuse.par('vx',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpwddiffuse.par('vy',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfpwddiffuse.par('order',rsf.doc.rsfpar('int','1','[1,2,3]','''accuracy order '''))
sfpwddiffuse.par('nj1',rsf.doc.rsfpar('int','1','','''antialiasing iline '''))
sfpwddiffuse.par('nj2',rsf.doc.rsfpar('int','1','','''antialiasing xline '''))
sfpwddiffuse.par('sm',rsf.doc.rsfpar('bool','y','','''if perform PWD filtering '''))
sfpwddiffuse.par('niter',rsf.doc.rsfpar('int','10','','''number of conjugate-gradient iterations '''))
sfpwddiffuse.par('repeat',rsf.doc.rsfpar('int','1','','''number of smoothing iterations '''))
sfpwddiffuse.par('eps',rsf.doc.rsfpar('float','1.','','''regularization parameter '''))
sfpwddiffuse.par('adj',rsf.doc.rsfpar('bool','n','','''adjoint flag - when test=y '''))
sfpwddiffuse.par('test',rsf.doc.rsfpar('bool','n','','''test - applied in either forward or adjoint mode (no inversion) '''))
sfpwddiffuse.version('2.1-git')
sfpwddiffuse.synopsis('''sfpwddiffuse < in.rsf dip=dip.rsf vx=fvx.rsf vy=fvy.rsf > out.rsf order=1 nj1=1 nj2=1 sm=y niter=10 repeat=1 eps=1. adj=n test=n''','''''')
rsf.doc.progs['sfpwddiffuse']=sfpwddiffuse

sfcerf = rsf.doc.rsfprog('sfcerf','user/dmerzlikin/Mcerf.cc','''None''')
sfcerf.version('2.1-git')
sfcerf.synopsis('''sfcerf''','''''')
rsf.doc.progs['sfcerf']=sfcerf

