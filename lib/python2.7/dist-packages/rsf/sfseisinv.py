import rsf.doc

sftkirmig = rsf.doc.rsfprog('sftkirmig','user/seisinv/Mtkirmig.c','''2-D Kirchhoff pre-stack time migration/demigration. ''')
sftkirmig.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sftkirmig.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sftkirmig.par('ompchunk',rsf.doc.rsfpar('int','1','','''OpenMP data chunk size '''))
sftkirmig.par('ompnth',rsf.doc.rsfpar('int','0','','''OpenMP available threads '''))
sftkirmig.par('adj',rsf.doc.rsfpar('bool','y','','''yes: migration, no: modeling '''))
sftkirmig.par('verb',rsf.doc.rsfpar('bool','n','','''verbosity flag '''))
sftkirmig.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sftkirmig.par('amp',rsf.doc.rsfpar('bool','y','','''if y, use amplitue factor '''))
sftkirmig.par('ncdp',rsf.doc.rsfpar('int','ncmp','',''''''))
sftkirmig.par('dcdp',rsf.doc.rsfpar('float','dcmp','',''''''))
sftkirmig.par('cdp0',rsf.doc.rsfpar('float','cmp0','',''''''))
sftkirmig.par('ncmp',rsf.doc.rsfpar('int','ncdp','',''''''))
sftkirmig.par('dcmp',rsf.doc.rsfpar('float','dcdp','',''''''))
sftkirmig.par('cmp0',rsf.doc.rsfpar('float','cdp0','',''''''))
sftkirmig.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sftkirmig.par('apt',rsf.doc.rsfpar('float','ncmp','','''migration aperture '''))
sftkirmig.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sftkirmig.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sftkirmig.version('2.1-git')
sftkirmig.synopsis('''sftkirmig < in.rsf vel=vel.rsf > out.rsf offset=offset.rsf ompchunk=1 ompnth=0 adj=y verb=n half=y amp=y ncdp=ncmp dcdp=dcmp cdp0=cmp0 ncmp=ncdp dcmp=dcdp cmp0=cdp0 antialias=1.0 apt=ncmp rho=1.-1./nt''','''The axes in the data are {time,cmp,offset}
The axes in the offset are {1,cmp,offset}
The axes in the image are {time,cdp,offset}
''')
rsf.doc.progs['sftkirmig']=sftkirmig

sftkirinv = rsf.doc.rsfprog('sftkirinv','user/seisinv/Mtkirinv.c','''2-D least-squares Kirchhoff pre-stack time migration with different regul..''')
sftkirinv.par('vel',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sftkirinv.par('offset',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sftkirinv.par('fdip',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sftkirinv.par('ompchunk',rsf.doc.rsfpar('int','1','','''OpenMP data chunk size '''))
sftkirinv.par('ompnth',rsf.doc.rsfpar('int','0','','''OpenMP available threads '''))
sftkirinv.par('verb',rsf.doc.rsfpar('bool','n','','''verbosity flag '''))
sftkirinv.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sftkirinv.par('amp',rsf.doc.rsfpar('bool','y','','''if y, use amplitue factor '''))
sftkirinv.par('ncdp',rsf.doc.rsfpar('int','ncmp','',''''''))
sftkirinv.par('dcdp',rsf.doc.rsfpar('float','dcmp','',''''''))
sftkirinv.par('cdp0',rsf.doc.rsfpar('float','cmp0','',''''''))
sftkirinv.par('reg',rsf.doc.rsfpar('int','0','','''regularization type '''))
sftkirinv.par('antialias',rsf.doc.rsfpar('float','1.0','','''antialiasing '''))
sftkirinv.par('apt',rsf.doc.rsfpar('float','ncmp','','''migration aperture '''))
sftkirinv.par('rho',rsf.doc.rsfpar('float','1.-1./nt','','''Leaky integration constant '''))
sftkirinv.par('niter',rsf.doc.rsfpar('int','5','','''number of iterations '''))
sftkirinv.par('nw',rsf.doc.rsfpar('int','3','',''''''))
sftkirinv.par('offset',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sftkirinv.par('err',rsf.doc.rsfpar('string ',desc='''output file for error '''))
sftkirinv.par('fdip',rsf.doc.rsfpar('string ',desc='''auxiliary input file name'''))
sftkirinv.version('2.1-git')
sftkirinv.synopsis('''sftkirinv < in.rsf vel=vel.rsf > out.rsf offset=offset.rsf fdip=fdip.rsf ompchunk=1 ompnth=0 verb=n half=y amp=y ncdp=ncmp dcdp=dcmp cdp0=cmp0 reg=0 antialias=1.0 apt=ncmp rho=1.-1./nt niter=5 nw=3 err=''','''regularization (or preconditioning) operator: 
reg=0: no regularization; 
reg=1: regularization => first derivative along offset axis;
reg=2: precondition => causual integration along offset axis;
reg=3: precondition => triangle smoother along offset axis, 
reg=4: precondition => local slope constraints along t-x plane and smoothing along offset axis 
''')
rsf.doc.progs['sftkirinv']=sftkirinv

sfcsp2d = rsf.doc.rsfprog('sfcsp2d','user/seisinv/Mcsp2d.c','''2-D common scattering-point gathers mapping and its adjoint''')
sfcsp2d.par('ompchunk',rsf.doc.rsfpar('int','1','','''OpenMP data chunk size '''))
sfcsp2d.par('ompnth',rsf.doc.rsfpar('int','0','','''OpenMP available threads '''))
sfcsp2d.par('adj',rsf.doc.rsfpar('bool','y','','''yes: CSP mapping, no: CMP building '''))
sfcsp2d.par('weight',rsf.doc.rsfpar('bool','n','','''weighting flag '''))
sfcsp2d.par('linear',rsf.doc.rsfpar('bool','n','','''yes: linear interpolation, no: nearest-neighbor interpolation '''))
sfcsp2d.par('v',rsf.doc.rsfpar('float','2000.','','''velocity '''))
sfcsp2d.par('half',rsf.doc.rsfpar('bool','n','','''half offset flag '''))
sfcsp2d.par('verb',rsf.doc.rsfpar('bool','n','','''verbosity flag '''))
sfcsp2d.par('nhe',rsf.doc.rsfpar('int','nh','',''''''))
sfcsp2d.par('dhe',rsf.doc.rsfpar('float','dh','',''''''))
sfcsp2d.par('he0',rsf.doc.rsfpar('float','h0','',''''''))
sfcsp2d.par('nxs',rsf.doc.rsfpar('int','nxm','',''''''))
sfcsp2d.par('dxs',rsf.doc.rsfpar('float','dxm','',''''''))
sfcsp2d.par('xs0',rsf.doc.rsfpar('float','xm0','',''''''))
sfcsp2d.par('nh',rsf.doc.rsfpar('int','nhe','',''''''))
sfcsp2d.par('dh',rsf.doc.rsfpar('float','dhe','',''''''))
sfcsp2d.par('h0',rsf.doc.rsfpar('float','he0','',''''''))
sfcsp2d.par('nxm',rsf.doc.rsfpar('int','nxs','',''''''))
sfcsp2d.par('dxm',rsf.doc.rsfpar('float','dxs','',''''''))
sfcsp2d.par('xm0',rsf.doc.rsfpar('float','xs0','',''''''))
sfcsp2d.par('apt',rsf.doc.rsfpar('float','SF_MAX(fabsf(he0),fabsf(he0+(nhe-1)*dhe))','','''aperture '''))
sfcsp2d.version('2.1-git Mcsp2d.c 744 2013-07-11 18:46:07Z Yujin Liu')
sfcsp2d.synopsis('''sfcsp2d < in.rsf > out.rsf ompchunk=1 ompnth=0 adj=y weight=n linear=n v=2000. half=n verb=n nhe=nh dhe=dh he0=h0 nxs=nxm dxs=dxm xs0=xm0 nh=nhe dh=dhe h0=he0 nxm=nxs dxm=dxs xm0=xs0 apt=SF_MAX(fabsf(he0),fabsf(he0+(nhe-1)*dhe))''','''The axes in the data space are {time,offset,cmp}
The axes in the image space are {time,equiv_offset,csp}
''')
rsf.doc.progs['sfcsp2d']=sfcsp2d

sfkirchinvs = rsf.doc.rsfprog('sfkirchinvs','user/seisinv/Mkirchinvs.c','''Kirchhoff 2-D post-stack least-squares time migration with sparse constrains. ''')
sfkirchinvs.par('velocity',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfkirchinvs.par('hd',rsf.doc.rsfpar('bool','y','','''if y, apply half-derivative filter '''))
sfkirchinvs.par('ps',rsf.doc.rsfpar('bool','y','','''if y, apply pseudo-unitary weighting '''))
sfkirchinvs.par('verb',rsf.doc.rsfpar('bool','n','','''verbosity flag '''))
sfkirchinvs.par('sw',rsf.doc.rsfpar('int','0','','''if > 0, select a branch of the antialiasing operation '''))
sfkirchinvs.par('niter',rsf.doc.rsfpar('int','5','','''number of non-linear iterations, when niter=1, it's linear '''))
sfkirchinvs.par('liter',rsf.doc.rsfpar('int','5','','''number of linear iterations '''))
sfkirchinvs.par('eps',rsf.doc.rsfpar('float','0.','','''regularization parameters '''))
sfkirchinvs.par('err',rsf.doc.rsfpar('string ',desc='''output file for error '''))
sfkirchinvs.version('2.1-git')
sfkirchinvs.synopsis('''sfkirchinvs < in.rsf > out.rsf velocity=vel.rsf hd=y ps=y verb=n sw=0 niter=5 liter=5 eps=0. err=''','''
Antialiasing by reparameterization. ''')
rsf.doc.progs['sfkirchinvs']=sfkirchinvs

sflsm_dsr2d = rsf.doc.rsfprog('sflsm_dsr2d','user/seisinv/Mlsm_dsr2d.c','''2-D prestack least-squares migration with split-step DSR. ''')
sflsm_dsr2d.par('slowness',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sflsm_dsr2d.par('error',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sflsm_dsr2d.par('verb',rsf.doc.rsfpar('bool','n','','''verbosity flag '''))
sflsm_dsr2d.par('eps',rsf.doc.rsfpar('float','0.01','','''stability parameter '''))
sflsm_dsr2d.par('niter',rsf.doc.rsfpar('int','10','','''number of iterations '''))
sflsm_dsr2d.par('nt',rsf.doc.rsfpar('int','1','','''taper size '''))
sflsm_dsr2d.par('nr',rsf.doc.rsfpar('int','1','','''maximum number of references '''))
sflsm_dsr2d.par('dt',rsf.doc.rsfpar('float','0.004','','''time error '''))
sflsm_dsr2d.par('npad',rsf.doc.rsfpar('int','0','','''padding on offset wavenumber '''))
sflsm_dsr2d.version('2.1-git')
sflsm_dsr2d.synopsis('''sflsm_dsr2d < in.rsf > out.rsf slowness=vel.rsf error=error.rsf verb=n eps=0.01 niter=10 nt=1 nr=1 dt=0.004 npad=0''','''''')
rsf.doc.progs['sflsm_dsr2d']=sflsm_dsr2d

sflsdmo = rsf.doc.rsfprog('sflsdmo','user/seisinv/Mlsdmo.c','''Kirchhoff least-squares DMO with antialiasing by reparameterization. ''')
sflsdmo.par('mint',rsf.doc.rsfpar('int','2','','''starting time sample '''))
sflsdmo.par('n',rsf.doc.rsfpar('int','32','','''number of offset samples '''))
sflsdmo.par('niter',rsf.doc.rsfpar('int','5','','''iterative number '''))
sflsdmo.par('inv',rsf.doc.rsfpar('bool','n','','''inversion flag '''))
sflsdmo.par('type',rsf.doc.rsfpar('int','1','','''type of amplitude (0,1,2,3) '''))
sflsdmo.par('h',rsf.doc.rsfpar('float','','',''''''))
sflsdmo.par('half',rsf.doc.rsfpar('bool','y','','''if y, the third axis is half-offset instead of full offset '''))
sflsdmo.par('velhalf',rsf.doc.rsfpar('float','0.75','','''half-velocity '''))
sflsdmo.version('2.1-git')
sflsdmo.synopsis('''sflsdmo < in.rsf > out.rsf mint=2 n=32 niter=5 inv=n type=1 h= half=y velhalf=0.75''','''''')
rsf.doc.progs['sflsdmo']=sflsdmo

sfvelxf3 = rsf.doc.rsfprog('sfvelxf3','user/seisinv/Mvelxf3.f90','''None''')
sfvelxf3.par('adj',rsf.doc.rsfpar('','0','','''adj = 0  : from velocity-domain(t,s) to cmp-gather(t,x)'''))
sfvelxf3.par('nx',rsf.doc.rsfpar('','nv','',''''''))
sfvelxf3.par('ny',rsf.doc.rsfpar('','1','',''''''))
sfvelxf3.par('dx',rsf.doc.rsfpar('','0.01','',''''''))
sfvelxf3.par('dy',rsf.doc.rsfpar('','0.01','',''''''))
sfvelxf3.par('ox',rsf.doc.rsfpar('','0.','',''''''))
sfvelxf3.par('oy',rsf.doc.rsfpar('','0.','',''''''))
sfvelxf3.par('nv',rsf.doc.rsfpar('','nx','',''''''))
sfvelxf3.par('dv',rsf.doc.rsfpar('','0.01','',''''''))
sfvelxf3.par('ov',rsf.doc.rsfpar('','1.5','',''''''))
sfvelxf3.version('2.1-git')
sfvelxf3.synopsis('''sfvelxf3 < vtr.rsf < cmp.rsf adj=0 nx=nv ny=1 dx=0.01 dy=0.01 ox=0. oy=0. nv=nx dv=0.01 ov=1.5''','''''')
rsf.doc.progs['sfvelxf3']=sfvelxf3

sfvelinvnew = rsf.doc.rsfprog('sfvelinvnew','user/seisinv/Mvelinvnew.f90','''None''')
sfvelinvnew.par('res',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfvelinvnew.par('vel0',rsf.doc.rsfpar('file   ',desc='''auxiliary input file name'''))
sfvelinvnew.par('mres',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfvelinvnew.par('velout',rsf.doc.rsfpar('file   ',desc='''auxiliary output file name'''))
sfvelinvnew.par('nv',rsf.doc.rsfpar('','nhx','',''''''))
sfvelinvnew.par('dv',rsf.doc.rsfpar('','0.01','',''''''))
sfvelinvnew.par('ov',rsf.doc.rsfpar('','1.5','',''''''))
sfvelinvnew.par('niter',rsf.doc.rsfpar('','20','',''''''))
sfvelinvnew.par('savevel',rsf.doc.rsfpar('','0','','''Flag to choose the algorithm'''))
sfvelinvnew.par('flag',rsf.doc.rsfpar('','0','',''''''))
sfvelinvnew.par('mflag',rsf.doc.rsfpar('','0','',''''''))
sfvelinvnew.par('huber',rsf.doc.rsfpar('','0','',''''''))
sfvelinvnew.par('irls',rsf.doc.rsfpar('','0','',''''''))
sfvelinvnew.par('nstep',rsf.doc.rsfpar('','1','',''''''))
sfvelinvnew.par('rwt',rsf.doc.rsfpar('','0.','',''''''))
sfvelinvnew.par('mwt',rsf.doc.rsfpar('','0.','',''''''))
sfvelinvnew.par('srate',rsf.doc.rsfpar('','0.01','',''''''))
sfvelinvnew.par('eps',rsf.doc.rsfpar('','0.01','',''''''))
sfvelinvnew.par('lamda',rsf.doc.rsfpar('','1000.','','''lamda controls sparsity, bigger lamda, more sparsity'''))
sfvelinvnew.par('delta',rsf.doc.rsfpar('','0.0001','','''delta controls update step and convergent, small delta ensure convergence but with small decrease in data fit error'''))
sfvelinvnew.par('step',rsf.doc.rsfpar('','0.000005','','''step is very important in convergence and sparsity'''))
sfvelinvnew.par('alpha',rsf.doc.rsfpar('','790.635','','''alpha always equals to the L2-norm of correct x'''))
sfvelinvnew.par('alpha',rsf.doc.rsfpar('','','','''smoothing parameter, typical value: 1 to 10 times estimated norm(x,inf)'''))
sfvelinvnew.par('lip',rsf.doc.rsfpar('','','','''the estimated Lipschitz constrant of the dual objective, default: alpha*normest(A*A',1e-2)'''))
sfvelinvnew.par('reset',rsf.doc.rsfpar('','','','''Nesterov's acceleration restart (theta is reset) or skip (theta is not reset)'''))
sfvelinvnew.version('2.1-git')
sfvelinvnew.synopsis('''sfvelinvnew < infile.rsf res=fres.rsf vel0=fm.rsf mres=fmres.rsf > outfile.rsf velout=vtr.rsf nv=nhx dv=0.01 ov=1.5 niter=20 savevel=0 flag=0 mflag=0 huber=0 irls=0 nstep=1 rwt=0. mwt=0. srate=0.01 eps=0.01 lamda=1000. delta=0.0001 step=0.000005 alpha=790.635 alpha= lip= reset=''','''''')
rsf.doc.progs['sfvelinvnew']=sfvelinvnew

