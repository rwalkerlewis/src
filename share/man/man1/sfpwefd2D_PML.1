.TH sfpwefd2D_PML 1  "APRIL 2019" Madagascar "Madagascar Manuals"
.SH NAME
sfpwefd2D_PML \- Short description line
.SH SYNOPSIS
.B sfpwefd2D_PML < Fwav.rsf sro=Fsro.rsf fro=Ffro.rsf phi=Fphi.rsf kdr=Fkdr.rsf kfl=Fkfl.rsf ksg=Fksg.rsf prm=Fprm.rsf fvs=Ffvs.rsf shm=Fshm.rsf tor=Ftor.rsf sou=Fsou.rsf rec=Frec.rsf wfl=Fwfl.rsf > Fdat.rsf ompchunk=1 ompnth=0 srctype=0 ani=-1 verb=y snap=n free=n dabc=y abcone=n debug=y cfl=y opot=n abcpml=n USE_PML_TOP=n USE_PML_BOTTOM=n USE_PML_LEFT=n USE_PML_RIGHT=n NPOINTS_PML=10 Rcoef=0.001f NPOWER=2.0f K_MAX_PML=1.0f nqz=sf_n(az) nqx=sf_n(ax) oqz=sf_o(az) oqx=sf_o(ax) nbell=1 jdata=1 nb=100 jsnap=nt fmax=
.SH COMMENTS
Comments here blablabla lorem ipsum dolores sit amet...

You can use several paragraphs for comments, no problem.
.SH PARAMETERS
.PD 0
.TP
.I float  
.B K_MAX_PML
.B =1.0f
.R  	! from Stephen Gedney's unpublished class notes for class EE699, lecture 8, slide 8-11
.TP
.I int    
.B NPOINTS_PML
.B =10
.R  
.TP
.I float  
.B NPOWER
.B =2.0f
.R  	power to compute d0 profile
.TP
.I float  
.B Rcoef
.B =0.001f
.R  	Reflection coefficient
.TP
.I bool   
.B USE_PML_BOTTOM
.B =n
.R  [y/n]	"PML ABC"
.TP
.I bool   
.B USE_PML_LEFT
.B =n
.R  [y/n]	"PML ABC"
.TP
.I bool   
.B USE_PML_RIGHT
.B =n
.R  [y/n]	"PML ABC"
.TP
.I bool   
.B USE_PML_TOP
.B =n
.R  [y/n]	"PML ABC"
.TP
.I bool   
.B abcone
.B =n
.R  [y/n]	use sharp brake at end of boundary layer
.TP
.I bool   
.B abcpml
.B =n
.R  [y/n]	"PML ABC"
.TP
.I int    
.B ani
.B =-1
.R  	Anisotropy type, see comments
.TP
.I bool   
.B cfl
.B =y
.R  [y/n]	use CFL check, will cause program to fail if not satisfied
.TP
.I bool   
.B dabc
.B =y
.R  [y/n]	use sponge absorbing BC
.TP
.I bool   
.B debug
.B =y
.R  [y/n]	print debugging info
.TP
.I float  
.B fmax
.B =
.R  
.TP
.I bool   
.B free
.B =n
.R  [y/n]	free surface flag
.TP
.I file   
.B fro
.B =
.R  	auxiliary input file name
.TP
.I file   
.B fvs
.B =
.R  	auxiliary input file name
.TP
.I int    
.B jdata
.B =1
.R  	Absorbing Boundary
.TP
.I int    
.B jsnap
.B =nt
.R  
.TP
.I file   
.B kdr
.B =
.R  	auxiliary input file name
.TP
.I file   
.B kfl
.B =
.R  	auxiliary input file name
.TP
.I file   
.B ksg
.B =
.R  	auxiliary input file name
.TP
.I int    
.B nb
.B =100
.R  	padding size for absorbing boundary
.TP
.I int    
.B nbell
.B =1
.R  	bell size
.TP
.I int    
.B nqx
.B =sf_n(ax)
.R  
.TP
.I int    
.B nqz
.B =sf_n(az)
.R  
.TP
.I int    
.B ompchunk
.B =1
.R  	OpenMP data chunk size
.TP
.I int    
.B ompnth
.B =0
.R  	OpenMP available threads
.TP
.I bool   
.B opot
.B =n
.R  [y/n]	output potentials
.TP
.I float  
.B oqx
.B =sf_o(ax)
.R  
.TP
.I float  
.B oqz
.B =sf_o(az)
.R  
.TP
.I file   
.B phi
.B =
.R  	auxiliary input file name
.TP
.I file   
.B prm
.B =
.R  	auxiliary input file name
.TP
.I file   
.B rec
.B =
.R  	auxiliary input file name
.TP
.I file   
.B shm
.B =
.R  	auxiliary input file name
.TP
.I bool   
.B snap
.B =n
.R  [y/n]	wavefield snapshots flag
.TP
.I file   
.B sou
.B =
.R  	auxiliary input file name
.TP
.I int    
.B srctype
.B =0
.R  	source type, see comments
.TP
.I file   
.B sro
.B =
.R  	auxiliary input file name
.TP
.I file   
.B tor
.B =
.R  	auxiliary input file name
.TP
.I bool   
.B verb
.B =y
.R  [y/n]	verbosity flag
.TP
.I file   
.B wfl
.B =
.R  	auxiliary output file name
.SH SOURCE
.I user/rlwalker/Mpwefd2D_PML.c
.SH VERSION
2.1-git
